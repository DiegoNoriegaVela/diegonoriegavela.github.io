import java.io.*;
import java.util.*;
import java.text.SimpleDateFormat;
import java.util.Calendar;

/**
 * MipManager - Gestor Integrado de Transferencia y Conversion de Archivos IPM
 * 
 * Sistema unificado que gestiona la transferencia de archivos IPM hacia/desde el MIP
 * de Mastercard, con capacidad de conversion automatica entre formatos ASCII y EBCDIC.
 * 
 * FUNCIONALIDAD PRINCIPAL:
 * 
 * Este gestor actua como capa de abstraccion sobre dos componentes:
 * 1. MipFileTransfer: Maneja la transferencia TCP/IP con el MIP
 * 2. IpmConverter: Maneja la codificacion/decodificacion EBCDIC <-> ASCII
 * 
 * FLUJOS DE OPERACION:
 * 
 * --------------------------------------------------------------------
 * MODO SEND (TO Mastercard)
 * --------------------------------------------------------------------
 * 
 * CASO 1: Archivo ya en EBCDIC (--encode EBCDIC)
 * ------------------------------------------------
 * [Archivo EBCDIC] -> MipFileTransfer -> [MIP]
 * 
 * Flujo directo sin conversion. El archivo ya tiene el formato IPM
 * correcto con RDW, VBS y 1014-blocking.
 * 
 * CASO 2: Archivo en ASCII (--encode ASCII)
 * ------------------------------------------
 * [Archivo ASCII] -> IpmConverter (encode) -> [Archivo IPM temporal]
 *                                                       |
 *                                                       v
 *                                          MipFileTransfer -> [MIP]
 *                                                       |
 *                                                       v
 *                                          [Limpieza de temporal]
 * 
 * El archivo ASCII se convierte primero a formato IPM usando IpmConverter,
 * creando un archivo temporal. Luego se transfiere y se elimina el temporal.
 * 
 * --------------------------------------------------------------------
 * MODO RECEIVE (FROM Mastercard) - FLUJO MODIFICADO
 * --------------------------------------------------------------------
 * 
 * NUEVO COMPORTAMIENTO:
 * 1. MipManager SIEMPRE llama a MipFileTransfer con '--file auto'
 * 2. MipFileTransfer recibe el archivo y lo guarda con nombre automatico
 *    en el directorio actual (ej: 00401T12030705.ipm)
 * 3. MipManager busca este archivo usando el patron 00401{ipmname}JJJ*.ipm
 * 4. MipManager extrae el nombre del archivo encontrado (sin extension)
 * 5. MipManager crea el archivo de destino final con:
 *    - Primera linea: [{nombre del archivo IPM}]
 *    - Resto: Contenido del archivo (EBCDIC directo o ASCII decodificado)
 * 6. MipManager elimina el archivo temporal IPM descargado
 * 
 * CASO 1: Mantener en EBCDIC (--encode EBCDIC)
 * ---------------------------------------------
 * [MIP] -> MipFileTransfer (auto) -> [00401...ipm en dir actual]
 *                                              |
 *                                              v
 *                                    [Buscar archivo generado]
 *                                              |
 *                                              v
 *                          [Archivo destino con header + contenido EBCDIC]
 *                                              |
 *                                              v
 *                                    [Eliminar 00401...ipm]
 * 
 * CASO 2: Convertir a ASCII (--encode ASCII)
 * -------------------------------------------
 * [MIP] -> MipFileTransfer (auto) -> [00401...ipm en dir actual]
 *                                              |
 *                                              v
 *                                    [Buscar archivo generado]
 *                                              |
 *                                              v
 *                         IpmConverter (decode) -> [Temporal ASCII]
 *                                              |
 *                                              v
 *                          [Archivo destino con header + contenido ASCII]
 *                                              |
 *                                              v
 *                          [Eliminar 00401...ipm y temporal ASCII]
 * 
 * PARAMETROS:
 * 
 * --mode <send|receive>  : Modo de operacion
 * --ip <direccion>       : IP del MIP
 * --port <puerto>        : Puerto del MIP
 * --file <path|auto>     : Archivo origen/destino o "auto" para naming automatico
 * --encode <EBCDIC|ASCII>: Formato del archivo
 * --ipmname <id>         : Transmission ID (ej: R119xxxxx o T112xxxxx)
 * --date <YYYYMMDD>      : Fecha para procesamiento (OBLIGATORIO en modo receive)
 * 
 * ARCHIVO DE CONFIGURACION (mipmanager.ini):
 * 
 * El archivo mipmanager.ini debe estar en el mismo directorio que MipManager.class
 * 
 * Formato:
 * [GENERAL]
 * miplog=/ruta/MIPFILE_HISTORY_R
 * autoNameReceive=/ruta/TXXX-AAAAMMDD-Archivo de Cambio Confirmacion
 * 
 * - miplog: Archivo donde se registran los envios exitosos
 *   Formato de registro: [9980100-R119028403050001: 2025-11-03 14:35:22]
 *   El Transmission ID se registra completo (14 caracteres) tal como fue enviado
 * 
 * - autoNameReceive: Patron para nombrado automatico de archivos recibidos
 *   TXXX: Primeros 4 caracteres del ipmname (ej: T120)
 *   AAAAMMDD: Fecha del parametro --date (ej: 20251103)
 * 
 * Ejemplo de uso con auto en receive:
 *   --file auto --ipmname T12002840 --date 20251103
 *   Genera archivo destino: /WC_MC/T120-20251103-Archivo de Cambio Confirmacion
 *   Con contenido: [00401T12030705] seguido del contenido
 * 
 * ARCHIVOS TEMPORALES:
 * 
 * Los archivos temporales se crean en el directorio temporal del sistema
 * con nombres unicos usando timestamp y UUID. Se garantiza su eliminacion
 * incluso en caso de error mediante bloques finally.
 * 
 * En modo RECEIVE, el archivo IPM descargado (00401...ipm) se guarda en el
 * directorio actual y se elimina automaticamente despues del procesamiento.
 * 
 * MODO DEBUG:
 * 
 * Al activar el modo debug con -Dmip.debug=true, se propaga automaticamente
 * a todos los componentes (MipFileTransfer e IpmConverter), mostrando:
 * - Detalles de conexion y protocolo
 * - Bytes en hexadecimal
 * - Deteccion de estructuras (RDW, blocking)
 * - Procesamiento de registros
 * - Busqueda de archivos IPM generados
 * 
 * MANEJO DE ERRORES:
 * 
 * - Validacion exhaustiva de parametros
 * - Limpieza garantizada de archivos temporales
 * - Mensajes de error descriptivos
 * - Exit codes apropiados (0=exito, 1=error, 2=uso incorrecto)
 * 
 * INTEGRACION:
 * 
 * Este programa NO reimplementa logica, sino que invoca:
 * - MipFileTransfer.main() para transferencias
 * - IpmConverter.main() para conversiones
 * 
 * Ambos componentes deben estar compilados y en el classpath.
 * 
 * Referencias:
 * - MipFileTransfer: Protocolo MIP de Mastercard
 * - IpmConverter: Formato VBS con RDW y 1014-blocking
 * - GCMS Reference Manual: Especificacion de archivos IPM
 * 
 * @author Sistema de Integracion Mastercard
 * @version 2.3
 * @since 2024
 */
public class MipManager {

    // Directorio temporal del sistema para archivos intermedios
    private static final String TEMP_DIR = System.getProperty("java.io.tmpdir");
    
    // Flag de debug global que se propaga a componentes
    private static final boolean DEBUG = Boolean.getBoolean("mip.debug");
    
    // Configuracion cargada desde mipmanager.ini
    private static Config config = null;

    public static void main(String[] args) {
        try {
            // Cargar configuracion desde mipmanager.ini
            config = loadConfig();
            
            // Parsear y validar parametros
            Params p = Params.parse(args);
            if (p == null) {
                printUsage();
                System.exit(2);
            }

            // Ejecutar operacion segun modo
            if ("send".equalsIgnoreCase(p.mode)) {
                executeSend(p);
            } else if ("receive".equalsIgnoreCase(p.mode)) {
                executeReceive(p);
            } else {
                System.err.println("ERROR: Modo invalido '" + p.mode + "'. Use 'send' o 'receive'");
                printUsage();
                System.exit(2);
            }

            System.exit(0);

        } catch (Exception e) {
            System.err.println("\n==============================================");
            System.err.println("ERROR FATAL");
            System.err.println("==============================================");
            System.err.println(e.getMessage());
            if (DEBUG) {
                e.printStackTrace();
            }
            System.err.println("==============================================");
            System.exit(1);
        }
    }

    /* ========================================================================
     * MODO SEND - Envio de archivos TO Mastercard
     * ======================================================================== */

    /**
     * Ejecuta el proceso completo de envio
     * 
     * LOGICA:
     * 1. Si encode=EBCDIC: transferencia directa
     * 2. Si encode=ASCII: conversion + transferencia + limpieza
     * 3. Registra el envio exitoso en el log configurado con Transmission ID completo
     * 
     * @param p Parametros de operacion
     * @throws Exception Si ocurre error en cualquier etapa
     */
    private static void executeSend(Params p) throws Exception {
        File sourceFile = new File(p.file);
        if (!sourceFile.exists()) {
            throw new FileNotFoundException("Archivo no encontrado: " + p.file);
        }

        System.out.println("==============================================");
        System.out.println("MIP MANAGER - MODO SEND");
        System.out.println("==============================================");
        System.out.println("Archivo origen : " + sourceFile.getName());
        System.out.println("Formato        : " + p.encode);
        System.out.println("Transmission ID: " + p.ipmName);
        System.out.println("MIP destino    : " + p.ip + ":" + p.port);
        if (DEBUG) {
            System.out.println("Modo DEBUG     : ACTIVADO (se propaga a componentes)");
        }
        System.out.println("==============================================\n");

        // Variables para capturar respuesta del servidor y Transmission ID usado
        String serverResponse = null;
        String fullTransmissionId = null;

        if ("EBCDIC".equalsIgnoreCase(p.encode)) {
            // CASO 1: Archivo ya en formato EBCDIC/IPM
            // Transferencia directa sin conversion
            System.out.println("[MODO DIRECTO] Archivo ya en formato EBCDIC");
            System.out.println("Iniciando transferencia...\n");
            
            TransferResult result = sendFileDirectWithResponse(p.ip, p.port, p.file, p.ipmName);
            serverResponse = result.serverResponse;
            fullTransmissionId = result.transmissionId;
            
            System.out.println("\n==============================================");
            System.out.println("ENVIO COMPLETADO EXITOSAMENTE");
            System.out.println("Archivo procesado: " + sourceFile.getName());
            System.out.println("==============================================");

        } else if ("ASCII".equalsIgnoreCase(p.encode)) {
            // CASO 2: Archivo en formato ASCII
            // Requiere conversion a IPM antes de enviar
            System.out.println("[MODO CONVERSION] Convertir a formato IPM");
            System.out.println("Codificacion EBCDIC requerida\n");

            File tempIpm = null;
            try {
                // PASO 1: Convertir ASCII a IPM usando IpmConverter
                System.out.println("[1/3] Codificando archivo ASCII a formato IPM...");
                tempIpm = createTempFile("ipm_encoded_", ".ipm");
                System.out.println("Archivo temporal: " + tempIpm.getAbsolutePath());
                
                encodeAsciiToIpm(p.file, tempIpm.getAbsolutePath());
                System.out.println("Codificacion completada\n");

                // PASO 2: Transferir archivo IPM
                System.out.println("[2/3] Transfiriendo archivo IPM al MIP...");
                TransferResult result = sendFileDirectWithResponse(p.ip, p.port, 
                    tempIpm.getAbsolutePath(), p.ipmName);
                serverResponse = result.serverResponse;
                fullTransmissionId = result.transmissionId;
                System.out.println("Transferencia completada\n");

                // PASO 3: Limpiar archivo temporal
                System.out.println("[3/3] Limpiando archivos temporales...");
                if (tempIpm.delete()) {
                    System.out.println("Archivo temporal eliminado");
                } else {
                    System.err.println("ADVERTENCIA: No se pudo eliminar archivo temporal: " 
                        + tempIpm.getAbsolutePath());
                }

                System.out.println("\n==============================================");
                System.out.println("ENVIO COMPLETADO EXITOSAMENTE");
                System.out.println("Archivo procesado: " + sourceFile.getName());
                System.out.println("Conversion: ASCII -> IPM");
                System.out.println("==============================================");

            } finally {
                // Garantizar limpieza de temporal incluso si hay error
                if (tempIpm != null && tempIpm.exists()) {
                    try {
                        tempIpm.delete();
                    } catch (Exception e) {
                        System.err.println("Error limpiando temporal: " + e.getMessage());
                    }
                }
            }

        } else {
            throw new IllegalArgumentException(
                "Valor invalido para --encode: '" + p.encode + "'. Use EBCDIC o ASCII");
        }
        
        // Registrar el envio exitoso en el log con Transmission ID COMPLETO
        if (serverResponse != null && fullTransmissionId != null && 
            config != null && config.miplog != null) {
            logSendSuccess(serverResponse, fullTransmissionId);
        }
    }

    /* ========================================================================
     * MODO RECEIVE - Recepcion de archivos FROM Mastercard
     * ======================================================================== */

    /**
     * Ejecuta el proceso completo de recepcion
     * 
     * LOGICA MODIFICADA:
     * 1. Determina nombre del archivo destino final (auto o especificado)
     * 2. Llama a MipFileTransfer con --file auto (siempre)
     * 3. Busca el archivo IPM generado automaticamente (00401{ipmname}JJJ*.ipm)
     * 4. Procesa el archivo segun encode:
     *    - EBCDIC: Copia directa con header
     *    - ASCII: Decodifica y luego copia con header
     * 5. Elimina archivos temporales
     * 
     * @param p Parametros de operacion
     * @throws Exception Si ocurre error en cualquier etapa
     */
    private static void executeReceive(Params p) throws Exception {
        // Resolver nombre de archivo de DESTINO FINAL
        String finalDestinationPath = p.file;
        if ("auto".equalsIgnoreCase(p.file)) {
            if (config == null || config.autoNameReceive == null) {
                throw new IllegalArgumentException(
                    "Para usar --file auto, debe configurar autoNameReceive en mipmanager.ini");
            }
            finalDestinationPath = generateAutoFileName(p.ipmName, p.date);
            System.out.println("Nombre automatico generado: " + finalDestinationPath);
        }
        
        System.out.println("==============================================");
        System.out.println("MIP MANAGER - MODO RECEIVE");
        System.out.println("==============================================");
        System.out.println("Archivo destino: " + finalDestinationPath);
        System.out.println("Formato        : " + p.encode);
        System.out.println("Transmission ID: " + p.ipmName);
        System.out.println("Fecha (--date) : " + p.date);
        System.out.println("MIP origen     : " + p.ip + ":" + p.port);
        if (DEBUG) {
            System.out.println("Modo DEBUG     : ACTIVADO (se propaga a componentes)");
        }
        System.out.println("==============================================\n");

        File downloadedIpmFile = null;
        String headerName = null;

        try {
            // PASO 1: Recibir archivo IPM del MIP
            System.out.println("[1/4] Solicitando archivo al MIP (usando --file auto)...");
            receiveFileDirect(p.ip, p.port, "auto", p.ipmName, p.date);
            System.out.println("Recepcion completada\n");

            // PASO 2: Buscar el archivo que MipFileTransfer acaba de crear
            System.out.println("[2/4] Buscando archivo IPM descargado...");
            downloadedIpmFile = findDownloadedFile(p.ipmName, p.date);

            if (downloadedIpmFile == null) {
                throw new FileNotFoundException(
                    "No se pudo encontrar el archivo IPM descargado en el directorio actual");
            }
            
            System.out.println("Archivo encontrado: " + downloadedIpmFile.getName());

            // Extraer nombre para el header (sin extension .ipm)
            String fileName = downloadedIpmFile.getName();
            int extIndex = fileName.lastIndexOf(".ipm");
            headerName = (extIndex > 0) ? fileName.substring(0, extIndex) : fileName;
            
            if (DEBUG) {
                System.out.println("DEBUG: Header a insertar: [" + headerName + "]");
            }

            // PASO 3: Procesar archivo segun formato
            System.out.println("[3/4] Procesando archivo...");

            if ("EBCDIC".equalsIgnoreCase(p.encode)) {
                // CASO 1: Mantener en formato EBCDIC/IPM
                // Copia directa del archivo IPM con header
                System.out.println("Modo EBCDIC: Copiando contenido con header...");
                
                prependHeaderAndCopy(downloadedIpmFile, finalDestinationPath, headerName);
                
                System.out.println("Archivo guardado: " + finalDestinationPath);
                System.out.println("\n==============================================");
                System.out.println("RECEPCION COMPLETADA EXITOSAMENTE");
                System.out.println("Archivo guardado: " + finalDestinationPath);
                System.out.println("Formato: EBCDIC con header [" + headerName + "]");
                System.out.println("==============================================");

            } else if ("ASCII".equalsIgnoreCase(p.encode)) {
                // CASO 2: Convertir a formato ASCII
                // Decodificar IPM y copiar con header
                System.out.println("Modo ASCII: Decodificando y copiando con header...");
                
                decodeIpmToAscii(downloadedIpmFile.getAbsolutePath(), 
                    finalDestinationPath, headerName);
                
                System.out.println("Archivo guardado: " + finalDestinationPath);
                System.out.println("\n==============================================");
                System.out.println("RECEPCION COMPLETADA EXITOSAMENTE");
                System.out.println("Archivo guardado: " + finalDestinationPath);
                System.out.println("Conversion: IPM -> ASCII");
                System.out.println("Formato: ASCII con header [" + headerName + "]");
                System.out.println("==============================================");

            } else {
                throw new IllegalArgumentException(
                    "Valor invalido para --encode: '" + p.encode + "'. Use EBCDIC o ASCII");
            }

        } finally {
            // PASO 4: Limpieza de archivo IPM descargado
            if (downloadedIpmFile != null && downloadedIpmFile.exists()) {
                System.out.println("\n[4/4] Limpiando archivo IPM descargado...");
                if (downloadedIpmFile.delete()) {
                    System.out.println("Archivo " + downloadedIpmFile.getName() + " eliminado");
                } else {
                    System.err.println("ADVERTENCIA: No se pudo eliminar " + 
                        downloadedIpmFile.getAbsolutePath());
                }
            }
        }
    }

    /* ========================================================================
     * INVOCACION DE COMPONENTES MEDIANTE PROCESOS EXTERNOS
     * ======================================================================== */

    /**
     * Envia archivo directamente usando MipFileTransfer y captura la respuesta
     * 
     * Ejecuta: java MipFileTransfer --mode send --ip ... --port ... --file ... --ipmname ...
     * 
     * Si el modo DEBUG esta activo, se propaga con -Dmip.debug=true
     * 
     * @param ip Direccion IP del MIP
     * @param port Puerto del MIP
     * @param filePath Path del archivo a enviar
     * @param ipmName Transmission ID (puede ser 9 o 14 caracteres)
     * @return TransferResult con codigo de respuesta y transmission ID completo usado
     * @throws Exception Si la transferencia falla
     */
    private static TransferResult sendFileDirectWithResponse(String ip, int port, String filePath, String ipmName) 
            throws Exception {
        
        List<String> command = new ArrayList<String>();
        command.add("java");
        
        // Propagar flag de debug si esta activo
        if (DEBUG) {
            command.add("-Dmip.debug=true");
        }
        
        command.add("MipFileTransfer");
        command.add("--mode");
        command.add("send");
        command.add("--ip");
        command.add(ip);
        command.add("--port");
        command.add(String.valueOf(port));
        command.add("--file");
        command.add(filePath);
        command.add("--ipmname");
        command.add(ipmName);
        
        // Ejecutar y capturar salida para extraer respuesta del servidor y transmission ID completo
        return executeJavaProcessAndExtractResponse(command, "MipFileTransfer (send)");
    }

    /**
     * Recibe archivo usando MipFileTransfer con --file auto y --date
     * 
     * MODIFICADO: Siempre pasa --file auto al MipFileTransfer
     *             Tambien pasa el parametro --date
     * 
     * Ejecuta: java MipFileTransfer --mode receive --ip ... --port ... 
     *          --file auto --ipmname ... --date ...
     * 
     * Si el modo DEBUG esta activo, se propaga con -Dmip.debug=true
     * 
     * @param ip Direccion IP del MIP
     * @param port Puerto del MIP
     * @param filePath Debe ser "auto"
     * @param ipmName Transmission ID
     * @param date Fecha en formato YYYYMMDD
     * @throws Exception Si la recepcion falla
     */
    private static void receiveFileDirect(String ip, int port, String filePath, String ipmName, String date) 
            throws Exception {
        
        List<String> command = new ArrayList<String>();
        command.add("java");
        
        // Propagar flag de debug si esta activo
        if (DEBUG) {
            command.add("-Dmip.debug=true");
        }
        
        command.add("MipFileTransfer");
        command.add("--mode");
        command.add("receive");
        command.add("--ip");
        command.add(ip);
        command.add("--port");
        command.add(String.valueOf(port));
        command.add("--file");
        command.add(filePath); // Siempre sera "auto"
        command.add("--ipmname");
        command.add(ipmName);
        command.add("--date");
        command.add(date);
        
        executeJavaProcess(command, "MipFileTransfer (receive)");
    }    /**
     * Determina si un archivo es del tipo IPM con estructura RDW
     * 
     * Archivos IPM con RDW:
     * - R111, R119, RSP1, RSP3 (envio TO Mastercard)
     * - T112, T120 (recepcion FROM Mastercard)
     * 
     * Archivos sin RDW (reportes/MPE):
     * - T007, T113, T121, T140, T150
     * - T067, T068, T167, T168
     * 
     * @param fileName Nombre del archivo (puede incluir path)
     * @return true si es archivo IPM con RDW, false si es reporte sin RDW
     */
    private static boolean isIpmFileType(String fileName) {
        String name = fileName.toUpperCase();
        
        // Archivos IPM con RDW (TO Mastercard)
        if (name.contains("R111") || name.contains("R119") || 
            name.contains("RSP1") || name.contains("RSP3")) {
            return true;
        }
        
        // Archivos IPM con RDW (FROM Mastercard)
        if (name.contains("T112") || name.contains("T120")) {
            return true;
        }
        
        // Archivos de reporte sin RDW
        if (name.contains("T007") || name.contains("T113") || name.contains("T121") ||
            name.contains("T140") || name.contains("T150")) {
            return false;
        }
        
        // Archivos MPE sin RDW
        if (name.contains("T067") || name.contains("T068") ||
            name.contains("T167") || name.contains("T168")) {
            return false;
        }
        
        // Por defecto, asumir IPM con RDW
        return true;
    }



    /**
     * Codifica archivo ASCII a formato IPM usando IpmConverter como proceso externo
     * 
     * Ejecuta: java IpmConverter encode --input ... --output ...
     * 
     * Si el modo DEBUG esta activo, se propaga con -Dipm.debug=true
     * 
     * @param inputAscii Path del archivo ASCII de entrada
     * @param outputIpm Path del archivo IPM de salida
     * @throws Exception Si la codificacion falla
     */
    private static void encodeAsciiToIpm(String inputAscii, String outputIpm) 
            throws Exception {
        
        // Detectar tipo de archivo por nombre
        String fileName = new File(outputIpm).getName().toUpperCase();
        boolean isIpmWithRdw = isIpmFileType(fileName);
        
        List<String> command = new ArrayList<String>();
        command.add("java");
        
        // Propagar flag de debug si esta activo
        if (DEBUG) {
            command.add("-Dipm.debug=true");
        }
        
        command.add("IpmConverter");
        
        // Seleccionar comando segun tipo de archivo
        if (isIpmWithRdw) {
            command.add("encodeipm");  // Para R111, R119, T112, T120 (con RDW)
            if (DEBUG) {
                System.out.println("DEBUG: Usando encodeipm (archivo IPM con RDW)");
            }
        } else {
            command.add("encode");     // Para reportes (EBCDIC plano)
            if (DEBUG) {
                System.out.println("DEBUG: Usando encode (EBCDIC plano sin RDW)");
            }
        }
        
        command.add("--input");
        command.add(inputAscii);
        command.add("--output");
        command.add(outputIpm);
        
        executeJavaProcess(command, "IpmConverter");
    }

    /**
     * Decodifica archivo IPM a formato ASCII y antepone el header
     * 
     * Este metodo:
     * 1. Crea un archivo temporal para la salida de IpmConverter
     * 2. Ejecuta IpmConverter para decodificar el IPM
     * 3. Escribe el archivo final con header + contenido decodificado
     * 4. Elimina el archivo temporal
     * 
     * Ejecuta: java IpmConverter decode --input ... --output <temporal>
     * 
     * Si el modo DEBUG esta activo, se propaga con -Dipm.debug=true
     * 
     * @param inputIpm Path del archivo IPM de entrada
     * @param finalOutputFile Path del archivo de salida final
     * @param headerName Nombre para el header (sin extension)
     * @throws Exception Si la decodificacion falla
     */
    private static void decodeIpmToAscii(String inputIpm, String finalOutputFile, String headerName) 
            throws Exception {
        
        File tempAsciiFile = null;
        try {
            // 1. Crear archivo temporal para salida de IpmConverter
            tempAsciiFile = createTempFile("decoded_ascii_", ".txt");
            if (DEBUG) {
                System.out.println("DEBUG: Archivo temporal ASCII: " + tempAsciiFile.getAbsolutePath());
            }

            // 2. Ejecutar IpmConverter para decodificar
            // Detectar tipo de archivo por nombre
            String fileName = new File(inputIpm).getName().toUpperCase();
            boolean isIpmWithRdw = isIpmFileType(fileName);
            
            List<String> command = new ArrayList<String>();
            command.add("java");
            if (DEBUG) {
                command.add("-Dipm.debug=true");
            }
            command.add("IpmConverter");
            
            // Seleccionar comando segun tipo de archivo
            if (isIpmWithRdw) {
                command.add("decodeipm");  // Para T112, T120 (con RDW)
                if (DEBUG) {
                    System.out.println("DEBUG: Usando decodeipm (archivo IPM con RDW)");
                }
            } else {
                command.add("decode");     // Para T113, T121, T140, T150, etc (sin RDW)
                if (DEBUG) {
                    System.out.println("DEBUG: Usando decode (EBCDIC plano sin RDW)");
                }
            }
            
            command.add("--input");
            command.add(inputIpm);
            command.add("--output");
            command.add(tempAsciiFile.getAbsolutePath());
            
            executeJavaProcess(command, "IpmConverter");
            System.out.println("Decodificacion completada");

            // 3. Escribir archivo final con header
            System.out.println("Escribiendo archivo final con header...");
            try (FileOutputStream fos = new FileOutputStream(finalOutputFile);
                 FileInputStream fis = new FileInputStream(tempAsciiFile)) {

                // Escribir header
                String headerLine = "[" + headerName + "]" + System.lineSeparator();
                fos.write(headerLine.getBytes());

                // Copiar contenido decodificado
                byte[] buffer = new byte[8192];
                int n;
                while ((n = fis.read(buffer)) > 0) {
                    fos.write(buffer, 0, n);
                }
            }

        } finally {
            // 4. Limpiar archivo temporal
            if (tempAsciiFile != null && tempAsciiFile.exists()) {
                if (DEBUG) {
                    System.out.println("DEBUG: Eliminando temporal ASCII: " + tempAsciiFile.getName());
                }
                tempAsciiFile.delete();
            }
        }
    }

    /* ========================================================================
     * BUSQUEDA Y PROCESAMIENTO DE ARCHIVOS
     * ======================================================================== */

    /**
     * Busca el archivo .ipm descargado por MipFileTransfer en el directorio actual
     * 
     * Patron de busqueda: 00401{primeros 9 chars de ipmname}JJJ*.ipm
     * Donde JJJ es el dia juliano calculado desde --date
     * 
     * Ejemplo:
     *   ipmName: T11200157305
     *   date: 20251103 (dia juliano 307)
     *   Patron: 00401T11200157307*.ipm
     *   Resultado: 00401T1120015730705.ipm
     * 
     * @param ipmName Transmission ID
     * @param date Fecha en formato YYYYMMDD
     * @return File del archivo IPM encontrado, o null si no existe
     * @throws Exception Si hay error en el calculo o busqueda
     */
    private static File findDownloadedFile(String ipmName, String date) throws Exception {
        // 1. Extraer primeros 9 caracteres del ipmname (ej: T11200157)
        String namePrefix;
        if (ipmName.length() >= 9) {
            namePrefix = ipmName.substring(0, 9);
        } else {
            throw new Exception(
                "ipmName '" + ipmName + "' es demasiado corto (minimo 9 caracteres)");
        }

        // 2. Calcular dia juliano (JJJ) desde la fecha
        Calendar cal = Calendar.getInstance();
        try {
            int year = Integer.parseInt(date.substring(0, 4));
            int month = Integer.parseInt(date.substring(4, 6));
            int day = Integer.parseInt(date.substring(6, 8));
            cal.set(year, month - 1, day); // month es 0-based en Calendar
        } catch (Exception e) {
            throw new IllegalArgumentException("Formato de fecha invalido: " + date);
        }
        String jjj = String.format("%03d", cal.get(Calendar.DAY_OF_YEAR));

        // 3. Construir prefijo de busqueda
        final String searchPrefix = "00401" + namePrefix + jjj;
        
        if (DEBUG) {
            System.out.println("DEBUG: Buscando archivo con prefijo: " + searchPrefix + "*.ipm");
        }

        // 4. Buscar en directorio actual
        File currentDir = new File(".");
        File[] matchingFiles = currentDir.listFiles(new FilenameFilter() {
            public boolean accept(File dir, String name) {
                return name.startsWith(searchPrefix) && name.endsWith(".ipm");
            }
        });

        if (matchingFiles == null || matchingFiles.length == 0) {
            System.err.println("ERROR: No se encontro archivo .ipm con prefijo: " + searchPrefix);
            return null;
        }

        if (matchingFiles.length > 1) {
            System.err.println("ADVERTENCIA: Multiples archivos encontrados, usando el primero:");
            for (File f : matchingFiles) {
                System.err.println("  - " + f.getName());
            }
        }
        
        if (DEBUG) {
            System.out.println("DEBUG: Archivo encontrado: " + matchingFiles[0].getName());
        }
        
        return matchingFiles[0];
    }

    /**
     * Escribe el header y copia el contenido binario de un archivo a otro
     * 
     * El archivo de salida tendra:
     * 1. Primera linea: [{headerName}]
     * 2. Contenido binario del archivo fuente (EBCDIC)
     * 
     * @param sourceFile Archivo fuente (IPM en EBCDIC)
     * @param destPath Path del archivo destino
     * @param headerName Nombre para el header (sin extension)
     * @throws IOException Si hay error en lectura/escritura
     */
    private static void prependHeaderAndCopy(File sourceFile, String destPath, String headerName) 
            throws IOException {
        
        // Crear directorios padre si no existen
        File destFile = new File(destPath);
        if (destFile.getParentFile() != null && !destFile.getParentFile().exists()) {
            destFile.getParentFile().mkdirs();
        }
        
        try (FileOutputStream fos = new FileOutputStream(destPath)) {
            // 1. Escribir header
            String headerLine = "[" + headerName + "]" + System.lineSeparator();
            fos.write(headerLine.getBytes());

            // 2. Copiar contenido binario (EBCDIC)
            try (FileInputStream fis = new FileInputStream(sourceFile)) {
                byte[] buffer = new byte[8192];
                int n;
                while ((n = fis.read(buffer)) > 0) {
                    fos.write(buffer, 0, n);
                }
            }
        }
        
        if (DEBUG) {
            System.out.println("DEBUG: Archivo EBCDIC copiado con header a: " + destPath);
        }
    }

    /* ========================================================================
     * EJECUCION DE PROCESOS EXTERNOS
     * ======================================================================== */

    /**
     * Ejecuta proceso Java externo y captura salida
     * 
     * @param command Comando a ejecutar
     * @param componentName Nombre del componente para mensajes de error
     * @throws Exception Si el proceso falla
     */
    private static void executeJavaProcess(List<String> command, String componentName) 
            throws Exception {
        
        if (DEBUG) {
            System.out.println("DEBUG: Ejecutando comando:");
            System.out.println("DEBUG: " + String.join(" ", command));
        }

        ProcessBuilder pb = new ProcessBuilder(command);
        pb.redirectErrorStream(true);
        Process process = pb.start();

        // Capturar salida
        BufferedReader reader = new BufferedReader(
            new InputStreamReader(process.getInputStream()));
        String line;
        while ((line = reader.readLine()) != null) {
            System.out.println(line);
        }

        int exitCode = process.waitFor();
        if (exitCode != 0) {
            throw new RuntimeException(componentName + " fallo con codigo: " + exitCode);
        }
    }

    /**
     * Ejecuta proceso Java externo, captura salida y extrae respuesta del servidor
     * 
     * Busca en la salida:
     * - Linea con Transmission ID completo (14 caracteres)
     * - Linea con respuesta del servidor (998...)
     * 
     * @param command Comando a ejecutar
     * @param componentName Nombre del componente para mensajes de error
     * @return TransferResult con respuesta del servidor y transmission ID
     * @throws Exception Si el proceso falla
     */
    private static TransferResult executeJavaProcessAndExtractResponse(
            List<String> command, String componentName) throws Exception {
        
        if (DEBUG) {
            System.out.println("DEBUG: Ejecutando comando:");
            System.out.println("DEBUG: " + String.join(" ", command));
        }

        ProcessBuilder pb = new ProcessBuilder(command);
        pb.redirectErrorStream(true);
        Process process = pb.start();

        String serverResponse = null;
        String transmissionId = null;

        // Capturar salida y buscar respuesta del servidor y transmission ID
        BufferedReader reader = new BufferedReader(
            new InputStreamReader(process.getInputStream()));
        String line;
        while ((line = reader.readLine()) != null) {
            System.out.println(line);
            
            // Buscar Transmission ID completo (14 caracteres)
            if (transmissionId == null && line.contains("Transmission ID")) {
                int idx = line.indexOf(":");
                if (idx >= 0 && idx + 2 < line.length()) {
                    String id = line.substring(idx + 1).trim();
                    if (id.length() == 14 && (id.startsWith("R") || id.startsWith("T"))) {
                        transmissionId = id;
                        if (DEBUG) {
                            System.out.println("DEBUG: Transmission ID capturado: " + transmissionId);
                        }
                    }
                }
            }
            
            // Buscar respuesta del servidor (998...)
            if (serverResponse == null && line.contains("998")) {
                if (line.contains("998/")) {
                    int idx = line.indexOf("998/");
                    if (idx >= 0 && idx + 7 < line.length()) {
                        String code = line.substring(idx, idx + 5).replace("/", "");
                        String rc = "00";
                        int rcIdx = line.indexOf("rc=", idx);
                        if (rcIdx >= 0 && rcIdx + 5 <= line.length()) {
                            rc = line.substring(rcIdx + 3, rcIdx + 5);
                        }
                        serverResponse = code + rc;
                        if (DEBUG) {
                            System.out.println("DEBUG: Server response capturado: " + serverResponse);
                        }
                    }
                } else if (line.contains("Trailer 998")) {
                    serverResponse = "9980100";
                }
            }
        }

        int exitCode = process.waitFor();
        if (exitCode != 0) {
            throw new RuntimeException(componentName + " fallo con codigo: " + exitCode);
        }

        // Valores por defecto si no se encontraron en la salida
        if (serverResponse == null) {
            serverResponse = "9980100";
        }
        
        if (transmissionId == null) {
            // Intentar extraer del comando
            for (int i = 0; i < command.size() - 1; i++) {
                if ("--ipmname".equals(command.get(i))) {
                    transmissionId = command.get(i + 1);
                    break;
                }
            }
        }

        return new TransferResult(serverResponse, transmissionId);
    }

    /* ========================================================================
     * CONFIGURACION
     * ======================================================================== */

    /**
     * Carga configuracion desde mipmanager.ini
     * 
     * El archivo debe estar en el mismo directorio que MipManager.class
     * 
     * Formato esperado:
     * [GENERAL]
     * miplog=/ruta/MIPFILE_HISTORY_R
     * autoNameReceive=/ruta/TXXX-AAAAMMDD-Archivo de Cambio Confirmacion
     * 
     * @return Objeto Config con configuracion cargada
     */
    private static Config loadConfig() {
        Config cfg = new Config();
        
        File iniFile = new File("mipmanager.ini");
        if (!iniFile.exists()) {
            if (DEBUG) {
                System.out.println("DEBUG: mipmanager.ini no encontrado");
            }
            return cfg;
        }
        
        try {
            BufferedReader reader = new BufferedReader(new FileReader(iniFile));
            String line;
            boolean inGeneralSection = false;
            
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                
                // Ignorar lineas vacias y comentarios
                if (line.isEmpty() || line.startsWith("#") || line.startsWith(";")) {
                    continue;
                }
                
                // Detectar seccion [GENERAL]
                if (line.equals("[GENERAL]")) {
                    inGeneralSection = true;
                    continue;
                }
                
                // Detectar otra seccion
                if (line.startsWith("[")) {
                    inGeneralSection = false;
                    continue;
                }
                
                // Procesar propiedades en seccion [GENERAL]
                if (inGeneralSection && line.contains("=")) {
                    String[] parts = line.split("=", 2);
                    String key = parts[0].trim();
                    String value = parts[1].trim();
                    
                    if ("miplog".equals(key)) {
                        cfg.miplog = value;
                    } else if ("autoNameReceive".equals(key)) {
                        cfg.autoNameReceive = value;
                    }
                }
            }
            reader.close();
            
            if (DEBUG) {
                System.out.println("DEBUG: Configuracion cargada:");
                System.out.println("DEBUG:   miplog = " + cfg.miplog);
                System.out.println("DEBUG:   autoNameReceive = " + cfg.autoNameReceive);
            }
            
        } catch (IOException e) {
            System.err.println("ADVERTENCIA: Error leyendo mipmanager.ini: " + e.getMessage());
        }
        
        return cfg;
    }

    /* ========================================================================
     * LOGGING
     * ======================================================================== */

    /**
     * Registra envio exitoso en el log configurado
     * 
     * Formato de entrada: [9980100-R119028403050001: 2025-11-03 14:35:22]
     * 
     * IMPORTANTE: Se registra el Transmission ID COMPLETO de 14 caracteres
     * tal como fue usado en la transferencia real al MIP.
     * 
     * @param serverResponse Codigo de respuesta del servidor
     * @param fullTransmissionId Transmission ID completo de 14 caracteres
     */
    private static void logSendSuccess(String serverResponse, String fullTransmissionId) {
        if (config.miplog == null) {
            return;
        }
        
        try {
            // Formato de timestamp
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            String timestamp = sdf.format(new Date());
            
            // Construir linea de log con Transmission ID COMPLETO
            String logLine = "[" + serverResponse + "-" + fullTransmissionId + ": " + timestamp + "]";
            
            // Escribir al archivo de log (append)
            File logFile = new File(config.miplog);
            
            // Crear directorios padre si no existen
            if (logFile.getParentFile() != null && !logFile.getParentFile().exists()) {
                logFile.getParentFile().mkdirs();
            }
            
            FileWriter fw = new FileWriter(logFile, true); // true = append
            BufferedWriter bw = new BufferedWriter(fw);
            
            bw.write(logLine);
            bw.newLine();
            bw.close();
            
            System.out.println("\nEnvio registrado en log: " + config.miplog);
            if (DEBUG) {
                System.out.println("DEBUG: Log entry: " + logLine);
            }
            
        } catch (IOException e) {
            System.err.println("ADVERTENCIA: No se pudo escribir en el log: " + e.getMessage());
        }
    }

    /**
     * Genera nombre de archivo automatico para receive
     * 
     * MODIFICADO: Usa la fecha del parametro --date en lugar de la fecha actual
     * 
     * Patron: /ruta/TXXX-AAAAMMDD-Archivo de Cambio Confirmacion
     * 
     * Donde:
     * - TXXX: Primeros 4 caracteres del ipmname (ej: T120)
     * - AAAAMMDD: Fecha del parametro --date (ej: 20251103)
     * 
     * @param ipmName Transmission ID
     * @param dateStr Fecha en formato YYYYMMDD (del parametro --date)
     * @return Ruta completa del archivo generado
     */
    private static String generateAutoFileName(String ipmName, String dateStr) {
        if (config.autoNameReceive == null) {
            throw new IllegalArgumentException(
                "autoNameReceive no configurado en mipmanager.ini");
        }
        
        // Extraer TXXX (primeros 4 caracteres del ipmname)
        String prefix = ipmName.length() >= 4 ? ipmName.substring(0, 4) : ipmName;
        
        // Usar la fecha del parametro --date
        String date = dateStr;
        
        // Reemplazar patrones en la configuracion
        String fileName = config.autoNameReceive;
        fileName = fileName.replace("TXXX", prefix);
        fileName = fileName.replace("AAAAMMDD", date);
        
        if (DEBUG) {
            System.out.println("DEBUG: Nombre auto-generado: " + fileName);
        }
        
        return fileName;
    }

    /* ========================================================================
     * UTILIDADES
     * ======================================================================== */

    /**
     * Crea archivo temporal con prefijo y sufijo especificados
     * 
     * El archivo se crea en el directorio temporal del sistema
     * con un nombre unico que incluye timestamp y UUID para
     * evitar colisiones.
     * 
     * Formato: <prefix><timestamp>_<uuid><suffix>
     * Ejemplo: ipm_encoded_20241031_a1b2c3d4.ipm
     * 
     * @param prefix Prefijo del nombre de archivo
     * @param suffix Sufijo del nombre de archivo (incluye extension)
     * @return File temporal creado
     * @throws IOException Si no se puede crear el archivo
     */
    private static File createTempFile(String prefix, String suffix) throws IOException {
        // Generar nombre unico con timestamp y UUID
        String timestamp = String.valueOf(System.currentTimeMillis());
        String uuid = UUID.randomUUID().toString().substring(0, 8);
        String filename = prefix + timestamp + "_" + uuid + suffix;
        
        File tempFile = new File(TEMP_DIR, filename);
        
        if (!tempFile.createNewFile()) {
            throw new IOException("No se pudo crear archivo temporal: " + tempFile.getAbsolutePath());
        }
        
        if (DEBUG) {
            System.out.println("DEBUG: Archivo temporal creado: " + tempFile.getAbsolutePath());
        }
        
        return tempFile;
    }

    /* ========================================================================
     * AYUDA Y USO
     * ======================================================================== */

    /**
     * Imprime mensaje de ayuda con instrucciones de uso
     */
    private static void printUsage() {
        System.out.println(
            "\n" +
            "==============================================\n" +
            "MIP MANAGER - Gestor Integrado de Archivos IPM\n" +
            "==============================================\n" +
            "\n" +
            "USO:\n" +
            "  java MipManager --mode <send|receive> --ip <direccion> --port <puerto> \\\n" +
            "       --file <path|auto> --encode <EBCDIC|ASCII> --ipmname <id> \\\n" +
            "       [--date <YYYYMMDD>]\n" +
            "\n" +
            "PARAMETROS REQUERIDOS:\n" +
            "\n" +
            "  --mode <send|receive>\n" +
            "      Modo de operacion:\n" +
            "      - send   : Enviar archivo AL MIP de Mastercard\n" +
            "      - receive: Recibir archivo DEL MIP de Mastercard\n" +
            "\n" +
            "  --ip <direccion>\n" +
            "      Direccion IP del MIP de Mastercard\n" +
            "\n" +
            "  --port <puerto>\n" +
            "      Puerto TCP del MIP\n" +
            "\n" +
            "  --file <path|auto>\n" +
            "      Archivo a procesar:\n" +
            "      - En modo SEND  : Path del archivo a enviar\n" +
            "      - En modo RECEIVE: Path donde guardar o \"auto\" para nombrado automatico\n" +
            "\n" +
            "  --encode <EBCDIC|ASCII>\n" +
            "      Formato del archivo:\n" +
            "      - EBCDIC: Formato IPM nativo (sin conversion)\n" +
            "      - ASCII : Formato de texto (requiere conversion)\n" +
            "\n" +
            "  --ipmname <id>\n" +
            "      Transmission ID de Mastercard (9 o 14 caracteres):\n" +
            "      - SEND    : R + tipo(3) + endpoint(5) [+ julian(3) + seq(2)]\n" +
            "      - RECEIVE : T + tipo(3) + endpoint(5) [+ julian(3) + seq(2)]\n" +
            "\n" +
            "PARAMETROS OPCIONALES:\n" +
            "\n" +
            "  --date <YYYYMMDD>\n" +
            "      Fecha para procesamiento:\n" +
            "      - OBLIGATORIO en modo RECEIVE\n" +
            "      - NO usar en modo SEND (se calcula automaticamente)\n" +
            "      - Usado para generar nombre de archivo auto en receive\n" +
            "      - Usado para buscar archivo IPM generado (dia juliano)\n" +
            "      Ejemplo: --date 20251103\n" +
            "\n" +
            "TRANSMISSION ID:\n" +
            "\n" +
            "  Formato de 9 caracteres (se completa automaticamente a 14):\n" +
            "    [R/T] + [tipo:3 digitos] + [endpoint:5 digitos]\n" +
            "\n" +
            "  Formato completo de 14 caracteres:\n" +
            "    [R/T] + [tipo:3] + [endpoint:5] + [julian:3] + [secuencia:2]\n" +
            "\n" +
            "  SEND : R + tipo(3) + endpoint(5) [+ julian(3) + seq(2)]\n" +
            "            Ejemplo: R11902840 or R119028403050001\n" +
            "\n" +
            "  RECEIVE : T + tipo(3) + endpoint(5) [+ julian(3) + seq(2)]\n" +
            "            Ejemplo: T11200157 or T112001573050001\n" +
            "\n" +
            "MODO RECEIVE - COMPORTAMIENTO:\n" +
            "\n" +
            "  1. MipManager SIEMPRE llama a MipFileTransfer con '--file auto'\n" +
            "  2. MipFileTransfer guarda el archivo como: 00401TXXEEEEEJJJSS.ipm\n" +
            "     en el directorio actual\n" +
            "  3. MipManager busca ese archivo usando ipmname y date\n" +
            "  4. MipManager crea el archivo de destino final con:\n" +
            "     Linea 1: [00401TXXEEEEEJJJSS]\n" +
            "     Resto: Contenido EBCDIC directo o ASCII decodificado\n" +
            "  5. MipManager elimina el archivo .ipm temporal\n" +
            "\n" +
            "Ejemplos:\n" +
            "\n" +
            "  1. Enviar archivo ASCII (conversion automatica):\n" +
            "     java MipManager --mode send --ip 10.0.0.1 --port 5000 \\\n" +
            "          --file records.txt --encode ASCII --ipmname R11902840\n" +
            "\n" +
            "  2. Enviar archivo EBCDIC (directo):\n" +
            "     java MipManager --mode send --ip 10.0.0.1 --port 5000 \\\n" +
            "          --file file.ipm --encode EBCDIC --ipmname R11902840\n" +
            "\n" +
            "  3. Recibir con auto-naming y fecha especifica:\n" +
            "     java MipManager --mode receive --ip 10.0.0.1 --port 5000 \\\n" +
            "          --file auto --encode ASCII --ipmname T12002840 --date 20251103\n" +
            "\n" +
            "  4. Recibir con nombre especifico:\n" +
            "     java MipManager --mode receive --ip 10.0.0.1 --port 5000 \\\n" +
            "          --file output.txt --encode ASCII --ipmname T11200157 --date 20251103\n" +
            "\n" +
            "  5. Recibir y mantener en EBCDIC:\n" +
            "     java MipManager --mode receive --ip 10.0.0.1 --port 5000 \\\n" +
            "          --file file.ipm --encode EBCDIC --ipmname T11200157 --date 20251103\n" +
            "\n" +
            "Archivos Temporales:\n" +
            "  Los archivos temporales se crean en: " + TEMP_DIR + "\n" +
            "  Se eliminan automaticamente despues de uso exitoso\n" +
            "  En modo RECEIVE, el archivo .ipm descargado se guarda en el directorio\n" +
            "  actual y se elimina automaticamente al finalizar\n" +
            "\n" +
            "Modo Debug:\n" +
            "  Para diagnostico detallado, ejecutar con:\n" +
            "  java -Dmip.debug=true MipManager ...\n" +
            "\n" +
            "  El modo debug se propaga automaticamente a todos los componentes\n" +
            "  (MipFileTransfer e IpmConverter), mostrando:\n" +
            "  - Detalles de protocolo y conexion\n" +
            "  - Bytes en formato hexadecimal\n" +
            "  - Deteccion de estructuras RDW y blocking\n" +
            "  - Procesamiento de registros\n" +
            "  - Busqueda de archivos IPM generados\n" +
            "\n" +
            "Componentes Requeridos:\n" +
            "  - MipFileTransfer.class : Transferencia TCP/IP con MIP\n" +
            "  - IpmConverter.class    : Conversion EBCDIC/ASCII con RDW\n" +
            "  - mipmanager.ini        : Archivo de configuracion (opcional)\n" +
            "  - Todos en el mismo directorio\n" +
            "\n" +
            "Exit Codes:\n" +
            "  0 : Operacion exitosa\n" +
            "  1 : Error durante ejecucion\n" +
            "  2 : Parametros incorrectos o invalidos\n" +
            "\n" +
            "==============================================\n"
        );
    }

    /* ========================================================================
     * CLASES AUXILIARES
     * ======================================================================== */

    /**
     * Clase para almacenar resultado de transferencia
     */
    private static class TransferResult {
        String serverResponse;
        String transmissionId;
        
        TransferResult(String serverResponse, String transmissionId) {
            this.serverResponse = serverResponse;
            this.transmissionId = transmissionId;
        }
    }

    /**
     * Clase para almacenar configuracion cargada desde mipmanager.ini
     */
    private static class Config {
        String miplog = null;
        String autoNameReceive = null;
    }

    /* ========================================================================
     * CLASE DE PARAMETROS
     * ======================================================================== */

    /**
     * Clase para parsear y almacenar parametros de linea de comandos
     * 
     * Parametros soportados:
     * - mode: send o receive
     * - ip: Direccion IP del MIP
     * - port: Puerto del MIP
     * - file: Path del archivo origen/destino o "auto"
     * - encode: EBCDIC o ASCII
     * - ipmName: Transmission ID
     * - date: Fecha en formato YYYYMMDD (obligatorio en receive)
     */
    private static class Params {
        String mode;
        String ip;
        int port;
        String file;
        String encode;
        String ipmName;
        String date;

        /**
         * Parsea argumentos de linea de comandos
         * 
         * Soporta formatos:
         * - --parametro=valor
         * - --parametro valor
         * 
         * @param args Array de argumentos
         * @return Objeto Params parseado, o null si faltan parametros requeridos
         */
        static Params parse(String[] args) {
            Params p = new Params();

            for (int i = 0; i < args.length; i++) {
                String arg = args[i];

                if (arg.startsWith("--mode=")) {
                    p.mode = arg.substring(7);
                } else if (arg.equals("--mode") && i + 1 < args.length) {
                    p.mode = args[++i];

                } else if (arg.startsWith("--ip=")) {
                    p.ip = arg.substring(5);
                } else if (arg.equals("--ip") && i + 1 < args.length) {
                    p.ip = args[++i];

                } else if (arg.startsWith("--port=")) {
                    try {
                        p.port = Integer.parseInt(arg.substring(7));
                    } catch (NumberFormatException e) {
                        System.err.println("ERROR: Puerto invalido: " + arg.substring(7));
                        return null;
                    }
                } else if (arg.equals("--port") && i + 1 < args.length) {
                    try {
                        p.port = Integer.parseInt(args[++i]);
                    } catch (NumberFormatException e) {
                        System.err.println("ERROR: Puerto invalido: " + args[i]);
                        return null;
                    }

                } else if (arg.startsWith("--file=")) {
                    p.file = arg.substring(7);
                } else if (arg.equals("--file") && i + 1 < args.length) {
                    p.file = args[++i];

                } else if (arg.startsWith("--encode=")) {
                    p.encode = arg.substring(9);
                } else if (arg.equals("--encode") && i + 1 < args.length) {
                    p.encode = args[++i];

                } else if (arg.startsWith("--ipmname=")) {
                    p.ipmName = arg.substring(10);
                } else if (arg.equals("--ipmname") && i + 1 < args.length) {
                    p.ipmName = args[++i];

                } else if (arg.startsWith("--date=")) {
                    p.date = arg.substring(7);
                } else if (arg.equals("--date") && i + 1 < args.length) {
                    p.date = args[++i];

                } else {
                    System.err.println("ERROR: Parametro desconocido: " + arg);
                    return null;
                }
            }

            // Validar que todos los parametros requeridos esten presentes
            if (p.mode == null || p.ip == null || p.port == 0 || 
                p.file == null || p.encode == null || p.ipmName == null) {
                
                System.err.println("ERROR: Faltan parametros requeridos");
                if (p.mode == null) System.err.println("  - Falta --mode");
                if (p.ip == null) System.err.println("  - Falta --ip");
                if (p.port == 0) System.err.println("  - Falta --port");
                if (p.file == null) System.err.println("  - Falta --file");
                if (p.encode == null) System.err.println("  - Falta --encode");
                if (p.ipmName == null) System.err.println("  - Falta --ipmname");
                
                return null;
            }

            // Validar valores de parametros
            if (!"send".equalsIgnoreCase(p.mode) && !"receive".equalsIgnoreCase(p.mode)) {
                System.err.println("ERROR: --mode debe ser 'send' o 'receive'");
                return null;
            }

            if (!"EBCDIC".equalsIgnoreCase(p.encode) && !"ASCII".equalsIgnoreCase(p.encode)) {
                System.err.println("ERROR: --encode debe ser 'EBCDIC' o 'ASCII'");
                return null;
            }

            // Validaciones especificas de --date
            if ("receive".equalsIgnoreCase(p.mode) && p.date == null) {
                System.err.println("ERROR: El parametro --date es OBLIGATORIO para modo receive");
                System.err.println("       Formato: --date YYYYMMDD (ejemplo: --date 20251103)");
                return null;
            }
            
            if ("send".equalsIgnoreCase(p.mode) && p.date != null) {
                System.err.println("ERROR: El parametro --date NO es valido para modo send");
                System.err.println("       En modo send, la fecha se calcula automaticamente");
                return null;
            }
            
            if (p.date != null && !p.date.matches("\\d{8}")) {
                System.err.println("ERROR: Formato de fecha invalido en --date");
                System.err.println("       Use formato YYYYMMDD (8 digitos)");
                System.err.println("       Ejemplo: --date 20251103");
                return null;
            }

            return p;
        }
    }
}
