import java.io.*;
import java.net.*;
import java.nio.charset.Charset;
import java.util.*;

/**
 * MipFileTransfer - Sistema de Transferencia de Archivos IPM hacia/desde MIP de Mastercard
 * 
 * Basado en el protocolo "File Transfer Manual Version 1.1" y logica del GCO_MIP original.
 * 
 * ENVIO (TO MASTERCARD):
 *   1. Conecta al MIP
 *   2. Intenta secuencias 01-99 hasta que el Header 004 sea aceptado
 *   3. Envia bloques de datos (archivo cortado en 980 bytes + 'R')
 *   4. Envia Trailer 998 con conteo de bloques
 *   5. Espera confirmacion final
 * 
 * RECEPCION (FROM MASTERCARD):
 *   1. Conecta al MIP
 *   2. Envia Request 101 con secuencias 01-99 hasta encontrar archivo
 *   3. Recibe bloques de datos
 *   4. Convierte de EBCDIC a ASCII y guarda
 * 
 * @version 4.0
 */
public final class MipFileTransfer {

    // ========================================================================
    // CONFIGURACION
    // ========================================================================
    
    private static final Charset EBCDIC = Charset.forName("Cp500");
    private static final Charset ASCII = Charset.forName("ISO-8859-1");
    
    private static final int DATA_CHUNK = 980;
    private static final int TIMEOUT = 60000;
    private static final int MAX_SEQ = 99;

    // ========================================================================
    // MAIN
    // ========================================================================

    public static void main(String[] args) {
        try {
            Params p = Params.parse(args);
            if (p == null) {
                usage();
                System.exit(2);
            }

            if ("send".equalsIgnoreCase(p.mode)) {
                sendToMip(p);
            } else if ("receive".equalsIgnoreCase(p.mode)) {
                receiveFromMip(p);
            } else {
                System.err.println("ERROR: Modo invalido. Use 'send' o 'receive'");
                usage();
                System.exit(2);
            }
        } catch (Exception e) {
            System.err.println("ERROR: " + e.getMessage());
            System.exit(1);
        }
    }

    // ========================================================================
    // SEND - Envio de archivo al MIP
    // ========================================================================
    
    private static void sendToMip(Params p) throws Exception {
        File f = new File(p.filePath);
        if (!f.exists()) {
            throw new FileNotFoundException("Archivo no encontrado: " + p.filePath);
        }

        System.out.println("==============================================");
        System.out.println("MIP FILE TRANSFER - SEND (TO MASTERCARD)");
        System.out.println("==============================================");
        System.out.println("Archivo        : " + f.getName());
        System.out.println("Tamano         : " + f.length() + " bytes");
        System.out.println("MIP            : " + p.ip + ":" + p.port);
        System.out.println("==============================================");

        // 1. Leer archivo
        byte[] fileBytes = readAllBytes(f);
        if (fileBytes.length == 0) {
            throw new IOException("El archivo esta vacio");
        }

        // 2. Particionar archivo (sin trailer)
        List<byte[]> dataBlocks = partFile(fileBytes);
        System.out.println("Bloques datos  : " + dataBlocks.size());

        // 3. Conectar al MIP
        Socket client = new Socket();
        client.connect(new InetSocketAddress(p.ip, p.port), TIMEOUT);
        client.setSoTimeout(TIMEOUT);
        System.out.println("Conexion       : OK\n");

        try {
            // 4. Determinar secuencia inicial
            int seqInicial = 1;
            if (p.ipmName.length() == 14) {
                seqInicial = Integer.parseInt(p.ipmName.substring(12, 14));
            }

            // 5. FASE 1: Buscar secuencia valida para el Header
            String txIdAceptado = null;
            
            System.out.println("[FASE 1] Consultando Header...");
            
            for (int seq = seqInicial; seq <= MAX_SEQ; seq++) {
                String seqStr = String.format("%02d", seq);
                String txId = buildTransmissionId(p.ipmName, p.date, seqStr);
                String header = buildHeader004(txId);
                
                // Enviar Header
                outSocket(client, header.getBytes());
                
                // Leer respuesta
                String resp = inSocket(client).trim();
                
                // Analizar respuesta
                McResponse mcResp = checkMcResponse("Consulta Header ", resp);
                
                if (mcResp.isAccepted) {
                    txIdAceptado = txId;
                    System.out.println("  Secuencia " + seqStr + ": ACEPTADO");
                    System.out.println("  Transmission ID: " + txIdAceptado);
                    break;
                } else if (mcResp.isDuplicate) {
                    System.out.println("  Secuencia " + seqStr + ": DUPLICADO (ya enviado)");
                    // Continuar con siguiente secuencia
                } else {
                    System.out.println("  Secuencia " + seqStr + ": RECHAZADO (" + mcResp.errorCode + ")");
                    // Continuar con siguiente secuencia
                }
            }
            
            if (txIdAceptado == null) {
                throw new IOException("No se encontro secuencia disponible (" + seqInicial + " - " + MAX_SEQ + " agotadas)");
            }

            // 6. FASE 2: Enviar bloques de datos
            System.out.println("\n[FASE 2] Enviando bloques de datos...");
            
            for (int i = 0; i < dataBlocks.size(); i++) {
                outSocket(client, dataBlocks.get(i));
                
                if ((i + 1) % 50 == 0 || i == dataBlocks.size() - 1) {
                    System.out.println("  Enviados: " + (i + 1) + "/" + dataBlocks.size());
                }
            }

            // 7. FASE 3: Enviar Trailer 998
            System.out.println("\n[FASE 3] Enviando Trailer...");
            outSocket(client, buildTrailer998(dataBlocks.size()));
            
            // 8. Esperar confirmacion final
            String respFinal = inSocket(client).trim();
            McResponse mcRespFinal = checkMcResponse("Trailer", respFinal);
            
            if (mcRespFinal.isAccepted) {
                System.out.println("\n==============================================");
                System.out.println("ENVIO COMPLETADO EXITOSAMENTE");
                System.out.println("Transmission ID: " + txIdAceptado);
                System.out.println("Bloques enviados: " + (dataBlocks.size() + 1));
                System.out.println("==============================================");
            } else {
                throw new IOException("Trailer rechazado: " + mcRespFinal.errorCode);
            }

        } finally {
            try { client.close(); } catch (Exception ignore) {}
        }
    }

    // ========================================================================
    // RECEIVE - Recepcion de archivo desde MIP
    // ========================================================================
    
    private static void receiveFromMip(Params p) throws Exception {
        System.out.println("==============================================");
        System.out.println("MIP FILE TRANSFER - RECEIVE (FROM MASTERCARD)");
        System.out.println("==============================================");
        System.out.println("Destino        : " + p.filePath);
        System.out.println("MIP            : " + p.ip + ":" + p.port);
        System.out.println("==============================================");

        // 1. Conectar al MIP
        Socket client = new Socket();
        client.connect(new InetSocketAddress(p.ip, p.port), TIMEOUT);
        client.setSoTimeout(TIMEOUT);
        System.out.println("Conexion       : OK\n");

        // 2. Determinar secuencia inicial
        int seqInicial = 1;
        if (p.ipmName.length() == 14) {
            seqInicial = Integer.parseInt(p.ipmName.substring(12, 14));
        }

        StringBuilder contenido = new StringBuilder();
        String txIdEncontrado = null;

        try {
            // 3. FASE 1: Buscar archivo con Request 101
            System.out.println("[FASE 1] Buscando archivo...");

            for (int seq = seqInicial; seq <= MAX_SEQ; seq++) {
                String seqStr = String.format("%02d", seq);
                String txId = buildTransmissionId(p.ipmName, p.date, seqStr);
                String request = buildRequest101(txId);

                // Enviar Request
                outSocket(client, request.getBytes());

                // Leer respuesta completa
                contenido = new StringBuilder();
                boolean moreData = true;

                while (moreData) {
                    String chunk = inSocket(client);
                    contenido.append(chunk);

                    if (contenido.indexOf("998") >= 0) {
                        moreData = false;
                    }
                }

                // Verificar si encontro el archivo
                if (contenido.indexOf("9980100") >= 0) {
                    txIdEncontrado = txId;
                    System.out.println("  Secuencia " + seqStr + ": ENCONTRADO");
                    System.out.println("  Transmission ID: " + txIdEncontrado);
                    break;
                } else {
                    if (seq <= 3 || seq % 10 == 0) {
                        System.out.println("  Secuencia " + seqStr + ": No encontrado");
                    }
                }
            }

            if (txIdEncontrado == null) {
                throw new IOException("No se encontro secuencia disponible (" + seqInicial + " - " + MAX_SEQ + " agotadas)");
            }

            // 4. FASE 2: Procesar y guardar contenido
            System.out.println("\n[FASE 2] Guardando archivo...");
            
            String data = processReceivedData(contenido.toString());

            // Escribir con header del nombre
            StringBuilder output = new StringBuilder();
            output.append("[").append(txIdEncontrado).append("]\n");
            output.append(data);

            writeToFile(p.filePath, output.toString());

            System.out.println("\n==============================================");
            System.out.println("RECEPCION COMPLETADA");
            System.out.println("Archivo: " + p.filePath);
            System.out.println("==============================================");

        } finally {
            try { client.close(); } catch (Exception ignore) {}
        }
    }

    // ========================================================================
    // CONSTRUCCION DE MENSAJES
    // ========================================================================
    
    /**
     * Construye el Transmission ID de 14 caracteres.
     * Formato: ipmName (9 chars) + Julian Day (3 chars) + Sequence (2 chars)
     * 
     * @param ipmName Nombre base (9 chars) o completo (14 chars)
     * @param date Fecha YYYYMMDD para calcular dia Juliano
     * @param sequence Secuencia "01"-"99"
     * @return Transmission ID de 14 caracteres
     */
    private static String buildTransmissionId(String ipmName, String date, String sequence) {
        if (ipmName == null || ipmName.isEmpty()) {
            throw new IllegalArgumentException("ipmName no puede ser vacio");
        }
        
        ipmName = ipmName.trim().toUpperCase();
        
        // Si ya tiene 14 caracteres, reemplazar solo la secuencia
        if (ipmName.length() == 14) {
            return ipmName.substring(0, 12) + sequence;
        }
        
        // Si tiene 9 caracteres, agregar Julian + Sequence
        if (ipmName.length() == 9) {
            int year = Integer.parseInt(date.substring(0, 4));
            int month = Integer.parseInt(date.substring(4, 6));
            int day = Integer.parseInt(date.substring(6, 8));
            
            int julianDay = toJulian(year, month, day) - toJulian(year - 1, 12, 31);
            String julianStr = String.format("%03d", julianDay);
            
            return ipmName + julianStr + sequence;
        }
        
        throw new IllegalArgumentException("ipmName debe tener 9 o 14 caracteres. Actual: " + ipmName.length());
    }
    
    /**
     * Construye Header 004 "To Mastercard" - Pagina 49 del Manual
     * 
     * Estructura (19 bytes minimo, hasta 60 bytes con opcionales):
     *   pos 1-3  : Request Code "004" (3 bytes)
     *   pos 4-5  : Record Type "01" (2 bytes)
     *   pos 6-19 : Transmission ID (14 bytes) - RtttEEEEEJJJSS
     *   --- Campos opcionales (no enviados en esta implementacion) ---
     *   pos 20-36: Filler (17 bytes)
     *   pos 37-40: Reserved - File Size (4 bytes)
     *   pos 41-44: Reserved - Sequence Number (4 bytes)
     *   pos 45-60: Filler (16 bytes)
     * 
     * @param txId Transmission ID de 14 caracteres
     * @return Header como String (19 caracteres)
     */
    private static String buildHeader004(String txId) {
        if (txId == null || txId.length() != 14) {
            throw new IllegalArgumentException("Transmission ID debe tener 14 caracteres");
        }
        // "004" = Request Code (solicitud de envio)
        // "01"  = Record Type (tipo de registro estandar)
        return "004" + "01" + txId;
    }
    
    /**
     * Construye Request 101 "From Mastercard" - Pagina 51 del Manual
     * 
     * Estructura (19 bytes):
     *   pos 1-3  : Request Code "101" (3 bytes)
     *   pos 4-5  : Record Type "01" (2 bytes)
     *   pos 6-19 : Transmission ID (14 bytes) - TtttEEEEEJJJSS
     * 
     * @param txId Transmission ID de 14 caracteres
     * @return Request como String (19 caracteres)
     */
    private static String buildRequest101(String txId) {
        if (txId == null || txId.length() != 14) {
            throw new IllegalArgumentException("Transmission ID debe tener 14 caracteres");
        }
        // "101" = Request Code (solicitud de recepcion)
        // "01"  = Record Type (tipo de registro estandar)
        return "101" + "01" + txId;
    }

/**
     * Construye Trailer 998 - Pagina 50 del Manual
     * 
     * Estructura (11 bytes total):
     *   pos 1-3  : Request Code "998" (3 bytes) - Indica fin de transmision
     *   pos 4-5  : Record Type "01" (2 bytes)
     *   pos 6-7  : Return Code "00" (2 bytes) - "00" = OK
     *   pos 8-11 : Number of Blocks (4 bytes Big-Endian)
     * 
     * @param dataBlockCount Cantidad de bloques de datos enviados
     * @return Trailer como byte[] (11 bytes)
     */
    private static byte[] buildTrailer998(int dataBlockCount) {
        byte[] trailer = new byte[11];
        
        byte[] prefix = "9980100".getBytes();
        System.arraycopy(prefix, 0, trailer, 0, 7);
        
        // Block count = dataBlocks + 1 (incluye el trailer)
        int totalCount = dataBlockCount + 1;
        byte[] countBytes = intToBytesBE(totalCount, 4);
        System.arraycopy(countBytes, 0, trailer, 7, 4);
        
        return trailer;
    }

    // ========================================================================
    // PARTICIONADO DE ARCHIVO (solo datos, sin trailer)
    // ========================================================================
    
    /**
     * Corta el archivo en bloques de 980 bytes y agrega 'R' al inicio de cada uno.
     * NO incluye el trailer (se envia por separado).
     * 
     * @param file Bytes del archivo a particionar
     * @return Lista de bloques de datos
     */
    private static List<byte[]> partFile(byte[] file) {
        List<byte[]> blocks = new ArrayList<byte[]>();

        int parts = (int) Math.ceil((double) file.length / DATA_CHUNK);
        if (parts == 0) parts = 1;

        for (int i = 0; i < parts; i++) {
            int start = i * DATA_CHUNK;
            int end = Math.min(start + DATA_CHUNK, file.length);
            int size = end - start;

            // Bloque = 'R' + datos
            byte[] block = new byte[size + 1];
            block[0] = (byte) 'R';  // Direction Indicator (ASCII)
            System.arraycopy(file, start, block, 1, size);
            
            blocks.add(block);
        }

        return blocks;
    }

    // ========================================================================
    // VALIDACION DE RESPUESTAS DEL MIP
    // ========================================================================
    
    /**
     * Clase para encapsular la respuesta del MIP
     */
    private static class McResponse {
        boolean isAccepted = false;
        boolean isDuplicate = false;
        String errorCode = "";
        String rawResponse = "";
    }
    

    /**
     * Clase para encapsular la respuesta del MIP
     */
    private static class McResponse {
        boolean isAccepted = false;
        boolean isDuplicate = false;
        String requestCode = "";   // "998", "004", etc.
        String recordType = "";    // "01", "6A", etc.
        String returnCode = "";    // "00" = OK, otros = error
        String rawResponse = "";
    }

    /**
     * Analiza la respuesta del MIP y determina si fue aceptada o rechazada.
     * 
     * Estructura de respuesta MIP (segun Manual paginas 50-51):
     *   pos 1-3: Request Code ("998" para ACK/NACK)
     *   pos 4-5: Record Type ("01" estandar, "6A" variante, etc.)
     *   pos 6-7: Return Code ("00" = OK, otros = error)
     * 
     * Codigos conocidos:
     *   9980100 : Aceptado (Request=998, Type=01, RC=00)
     *   9980101 : Error generico
     *   9288W   : Archivo duplicado (ya enviado anteriormente)
     * 
     * @param stage Nombre de la etapa (para logging)
     * @param response Respuesta recibida del MIP (ya convertida a ASCII)
     * @return McResponse con el resultado del analisis
     */
    private static McResponse checkMcResponse(String stage, String response) {
        McResponse result = new McResponse();
        result.rawResponse = response;
        
        System.out.println("  [" + stage + "]");
        System.out.println("    Respuesta MIP: " + response);
        
        // Caso: Duplicado (archivo ya enviado)
        if (response.contains("9288W")) {
            result.isDuplicate = true;
            result.requestCode = "928";
            result.returnCode = "8W";
            System.out.println("    Request Code : 928");
            System.out.println("    Return Code  : 8W (DUPLICADO)");
            System.out.println("    Resultado    : ARCHIVO YA ENVIADO");
            return result;
        }
        
        // Buscar respuesta tipo 998
        int idx = response.indexOf("998");
        if (idx >= 0) {
            // Extraer componentes de la respuesta
            result.requestCode = "998";
            
            if (idx + 5 <= response.length()) {
                result.recordType = response.substring(idx + 3, idx + 5);
            }
            
            if (idx + 7 <= response.length()) {
                result.returnCode = response.substring(idx + 5, idx + 7);
            }
            
            System.out.println("    Request Code : " + result.requestCode);
            System.out.println("    Record Type  : " + result.recordType);
            System.out.println("    Return Code  : " + result.returnCode);
            
            // Evaluar Return Code
            if ("00".equals(result.returnCode)) {
                result.isAccepted = true;
                System.out.println("    Resultado    : ACEPTADO");
            } else {
                System.out.println("    Resultado    : RECHAZADO");
            }
            
            return result;
        }
        
        // Respuesta no reconocida
        System.out.println("    Request Code : ???");
        System.out.println("    Resultado    : RESPUESTA NO RECONOCIDA");
        result.returnCode = "??";
        
        return result;
    }

    // ========================================================================
    // COMUNICACION SOCKET
    // ========================================================================
    
    /**
     * Envia datos al socket con framing de 2 bytes y conversion a EBCDIC.
     */
    private static void outSocket(Socket socket, byte[] data) throws IOException {
        int len = data.length;
        
        // Convertir de ASCII a EBCDIC usando Charset
        String asciiStr = new String(data, ASCII);
        byte[] ebcdicData = asciiStr.getBytes(EBCDIC);
        
        // Buffer: 2 bytes longitud + datos EBCDIC
        byte[] buffer = new byte[len + 2];
        
        // 2 bytes de longitud (Big-Endian)
        buffer[0] = (byte) ((len >> 8) & 0xFF);
        buffer[1] = (byte) (len & 0xFF);
        
        // Copiar datos convertidos a EBCDIC
        System.arraycopy(ebcdicData, 0, buffer, 2, len);

        // Caso especial: Trailer 998 (11 bytes) - el count NO se convierte
        if (len == 11 && data[0] == '9' && data[1] == '9' && data[2] == '8') {
            buffer[9] = data[7];
            buffer[10] = data[8];
            buffer[11] = data[9];
            buffer[12] = data[10];
        }

        socket.getOutputStream().write(buffer, 0, len + 2);
        socket.getOutputStream().flush();
    }

    /**
     * Lee datos del socket y convierte de EBCDIC a ASCII.
     */
    private static String inSocket(Socket socket) throws IOException {
        byte[] buffer = new byte[1024];

        int bytesRead = socket.getInputStream().read(buffer, 0, 1024);

        if (bytesRead > 0) {
            // Convertir de EBCDIC a ASCII usando Charset
            String result = new String(buffer, 0, bytesRead, EBCDIC);
            
            return result;
        }

        return "";
    }

    // ========================================================================
    // UTILIDADES
    // ========================================================================
    
    private static int toJulian(int year, int month, int day) {
        int i = year;
        if (year < 0) i++;

        int j = month;
        if (month > 2) {
            j++;
        } else {
            i--;
            j += 13;
        }

        int k = (int) (Math.floor(365.25D * i) + Math.floor(30.6001D * j) + day + 1720995.0D);
        int m = 588829;

        if (day + 31 * (month + 12 * year) >= m) {
            int n = (int) (0.01D * i);
            k += 2 - n + (int) (0.25D * n);
        }

        return k;
    }

    private static byte[] readAllBytes(File f) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream((int) f.length());
        FileInputStream in = new FileInputStream(f);
        try {
            byte[] buf = new byte[8192];
            int n;
            while ((n = in.read(buf)) >= 0) {
                out.write(buf, 0, n);
            }
        } finally {
            in.close();
        }
        return out.toByteArray();
    }

    private static void writeToFile(String path, String content) throws IOException {
        FileWriter writer = new FileWriter(path);
        try {
            writer.write(content);
        } finally {
            writer.close();
        }
    }

    private static byte[] intToBytesBE(int num, int bytes) {
        byte[] result = new byte[bytes];
        for (int i = bytes - 1; i >= 0; i--) {
            result[i] = (byte) (num & 0xFF);
            num >>= 8;
        }
        return result;
    }

    private static String processReceivedData(String raw) {
        StringBuilder clean = new StringBuilder();
        String[] lines = raw.split("\n");

        for (String line : lines) {
            if (!line.contains("998") && line.length() > 0) {
                clean.append(line).append("\n");
            }
        }

        return clean.toString();
    }

    // ========================================================================
    // PARSEO DE ARGUMENTOS
    // ========================================================================
    
    private static void usage() {
        System.out.println(
            "MipFileTransfer - Transferencia de archivos MIP Mastercard\n" +
            "\n" +
            "Uso:\n" +
            "  ENVIO:\n" +
            "    java MipFileTransfer --mode send --ip <host> --port <puerto> \\\n" +
            "         --file <archivo> --ipmname <R278xxxxx> --date <YYYYMMDD>\n" +
            "\n" +
            "  RECEPCION:\n" +
            "    java MipFileTransfer --mode receive --ip <host> --port <puerto> \\\n" +
            "         --file <archivo_salida> --ipmname <T279xxxxx> --date <YYYYMMDD>\n" +
            "\n" +
            "Parametros:\n" +
            "  --mode     : 'send' o 'receive'\n" +
            "  --ip       : Direccion IP del MIP\n" +
            "  --port     : Puerto del MIP\n" +
            "  --file     : Archivo de entrada (send) o salida (receive)\n" +
            "  --ipmname  : Identificador de 9 o 14 caracteres\n" +
            "               9 chars: R27802840 (se agrega Julian+Seq automatico)\n" +
            "               14 chars: R2780284001501 (se usa tal cual, variando Seq)\n" +
            "  --date     : Fecha en formato YYYYMMDD\n" +
        );
    }

    private static final class Params {
        String mode;
        String ip;
        int port;
        String filePath;
        String ipmName;
        String date;

        static Params parse(String[] args) {
            Params p = new Params();

            for (int i = 0; i < args.length; i++) {
                String s = args[i];

                if (s.startsWith("--mode=")) {
                    p.mode = s.substring(7);
                } else if (s.equals("--mode") && i + 1 < args.length) {
                    p.mode = args[++i];
                } else if (s.startsWith("--ip=")) {
                    p.ip = s.substring(5);
                } else if (s.equals("--ip") && i + 1 < args.length) {
                    p.ip = args[++i];
                } else if (s.startsWith("--port=")) {
                    p.port = Integer.parseInt(s.substring(7));
                } else if (s.equals("--port") && i + 1 < args.length) {
                    p.port = Integer.parseInt(args[++i]);
                } else if (s.startsWith("--file=")) {
                    p.filePath = s.substring(7);
                } else if (s.equals("--file") && i + 1 < args.length) {
                    p.filePath = args[++i];
                } else if (s.startsWith("--ipmname=")) {
                    p.ipmName = s.substring(10);
                } else if (s.equals("--ipmname") && i + 1 < args.length) {
                    p.ipmName = args[++i];
                } else if (s.startsWith("--date=")) {
                    p.date = s.substring(7);
                } else if (s.equals("--date") && i + 1 < args.length) {
                    p.date = args[++i];
                }
            }

            // Validaciones
            if (p.mode == null || p.ip == null || p.port == 0 ||
                p.filePath == null || p.ipmName == null || p.date == null) {
                return null;
            }

            if (!p.date.matches("\\d{8}")) {
                System.err.println("ERROR: Formato de fecha invalido. Use YYYYMMDD");
                return null;
            }
            
            if (p.ipmName.length() != 9 && p.ipmName.length() != 14) {
                System.err.println("ERROR: ipmname debe tener 9 o 14 caracteres");
                return null;
            }

            return p;
        }
    }
}
