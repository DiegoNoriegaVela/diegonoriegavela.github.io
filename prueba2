#!/bin/bash

# --- CONFIGURACIÓN ---
# Asegúrate de exportar estas variables antes o definirlas aquí
# export ESP_DB_USER="tu_usuario"
# export ESP_DB_PASS="tu_contraseña"
DB_CONNString="${ESP_DB_USER}/${ESP_DB_PASS}@//tuhost:tuport/tuservice"

# Nombre de archivos temporales
SQL_FILE="temp_script.sql"
RESULT_FILE="temp_result.txt"

# Función para limpiar archivos temporales al salir
cleanup() {
    rm -f $SQL_FILE $RESULT_FILE
}
trap cleanup EXIT

# ==========================================
# MENÚ PRINCIPAL
# ==========================================
show_menu() {
    clear
    echo "========================================"
    echo "   GESTOR DE TRACKING (Shell Helper)"
    echo "========================================"
    echo "1. Consultar y Actualizar (Primer Comportamiento)"
    echo "2. Rollback / Revertir cambios (Segundo Comportamiento)"
    echo "3. Salir"
    echo "========================================"
    read -p "Seleccione una opción: " OPCION
}

# ==========================================
# COMPORTAMIENTO 1: CONSULTA Y UPDATE
# ==========================================
do_process() {
    echo ""
    read -p "Ingrese el BIN a consultar: " BIN_INPUT
    
    # 1. Generar el script SQL para obtener los grupos
    # Usamos concatenación con pipe '|' para facilitar la lectura en bash
    echo "SET PAGESIZE 0 FEEDBACK OFF VERIFY OFF HEADING OFF ECHO OFF" > $SQL_FILE
    echo "SELECT TO_CHAR(BATCH, 'DD/MM/YYYY') || '|' || COUNT(*) " >> $SQL_FILE
    echo "FROM esp.card" >> $SQL_FILE
    echo "WHERE TRIM(BIN) = '$BIN_INPUT'" >> $SQL_FILE
    echo "AND TRACKING = 'P'" >> $SQL_FILE
    echo "GROUP BY BATCH, BIN, TRACKING" >> $SQL_FILE
    echo "ORDER BY BATCH;" >> $SQL_FILE
    echo "EXIT;" >> $SQL_FILE

    # 2. Ejecutar sqlplus y guardar resultado
    sqlplus -S $DB_CONNString @$SQL_FILE > $RESULT_FILE

    # 3. Leer el resultado en un array
    # Verificamos si hay resultados
    if [ ! -s $RESULT_FILE ]; then
        echo "No se encontraron registros en estado 'P' para el BIN $BIN_INPUT."
        read -p "Presione Enter para continuar..."
        return
    fi

    echo ""
    echo "--- Registros encontrados para BIN: $BIN_INPUT ---"
    
    # Declaramos arrays
    declare -a BATCHES
    declare -a COUNTS
    i=1

    # Leemos linea por linea el archivo generado
    while IFS='|' read -r batch_date count_val; do
        # Limpiamos espacios en blanco
        batch_date=$(echo $batch_date | xargs)
        count_val=$(echo $count_val | xargs)
        
        if [ -n "$batch_date" ]; then
            BATCHES[$i]=$batch_date
            COUNTS[$i]=$count_val
            echo "$i) BIN: $BIN_INPUT | TRACKING: P | BATCH: $batch_date | COUNT: $count_val"
            ((i++))
        fi
    done < $RESULT_FILE

    echo ""
    echo "IMPORTANTE: Seleccione la opción que desea MANTENER en 'P'."
    echo "El resto de grupos se actualizarán a 'K' momentáneamente."
    read -p "Ingrese el número de opción: " SELECTION

    # Validar selección
    if [[ -z "${BATCHES[$SELECTION]}" ]]; then
        echo "Opción inválida."
        return
    fi

    SELECTED_BATCH="${BATCHES[$SELECTION]}"
    echo ">> Ha seleccionado mantener el BATCH: $SELECTED_BATCH"
    
    # 4. Generar el script de UPDATE para los NO seleccionados
    echo "Generando script de actualización..."
    
    echo "SET FEEDBACK ON" > $SQL_FILE
    echo "PROMPT Actualizando registros no seleccionados a 'K'..." >> $SQL_FILE
    
    # Recorremos el array para crear los updates de los que NO fueron elegidos
    for idx in "${!BATCHES[@]}"; do
        if [ "$idx" -ne "$SELECTION" ]; then
            CURRENT_BATCH="${BATCHES[$idx]}"
            # Query de update específica para ese grupo
            echo "UPDATE esp.card SET TRACKING = 'K'" >> $SQL_FILE
            echo "WHERE TRIM(BIN) = '$BIN_INPUT'" >> $SQL_FILE
            echo "AND BATCH = TO_DATE('$CURRENT_BATCH', 'DD/MM/YYYY')" >> $SQL_FILE
            echo "AND TRACKING = 'P';" >> $SQL_FILE
        fi
    done
    
    echo "COMMIT;" >> $SQL_FILE
    echo "PROMPT Proceso terminado." >> $SQL_FILE
    echo "EXIT;" >> $SQL_FILE

    # 5. Ejecutar los updates
    echo "Ejecutando cambios en base de datos..."
    sqlplus -S $DB_CONNString @$SQL_FILE
    
    read -p "Operación completada. Presione Enter para volver."
}

# ==========================================
# COMPORTAMIENTO 2: ROLLBACK (REVERTIR)
# ==========================================
do_rollback() {
    echo ""
    echo "--- MODO ROLLBACK ---"
    read -p "Ingrese el BIN para realizar el rollback (K -> P): " BIN_INPUT

    # 1. Mostrar estado actual (Informativo)
    echo "Consultando estado actual..."
    echo "SET PAGESIZE 50 FEEDBACK OFF VERIFY OFF HEADING ON" > $SQL_FILE
    echo "SELECT BIN, TRACKING, BATCH, COUNT(*) FROM esp.card WHERE TRIM(BIN)='$BIN_INPUT' GROUP BY BIN, TRACKING, BATCH;" >> $SQL_FILE
    echo "EXIT;" >> $SQL_FILE
    
    sqlplus -S $DB_CONNString @$SQL_FILE

    echo ""
    read -p "¿Desea revertir todos los registros con TRACKING 'K' a 'P' para este BIN? (S/N): " CONFIRM
    
    if [[ "$CONFIRM" != "S" && "$CONFIRM" != "s" ]]; then
        echo "Cancelado."
        return
    fi

    # 2. Ejecutar el Update Inverso (Rollback manual)
    echo "Realizando Rollback..."
    echo "UPDATE esp.card SET TRACKING = 'P'" > $SQL_FILE
    echo "WHERE TRIM(BIN) = '$BIN_INPUT'" >> $SQL_FILE
    echo "AND TRACKING = 'K';" >> $SQL_FILE
    echo "COMMIT;" >> $SQL_FILE
    
    # 3. Mostrar resultado final
    echo "PROMPT Estado final:" >> $SQL_FILE
    echo "SELECT BIN, TRACKING, BATCH, COUNT(*) FROM esp.card WHERE TRIM(BIN)='$BIN_INPUT' GROUP BY BIN, TRACKING, BATCH;" >> $SQL_FILE
    echo "EXIT;" >> $SQL_FILE

    sqlplus -S $DB_CONNString @$SQL_FILE

    read -p "Rollback finalizado. Presione Enter para volver."
}

# ==========================================
# BUCLE PRINCIPAL
# ==========================================
while true; do
    show_menu
    case $OPCION in
        1) do_process ;;
        2) do_rollback ;;
        3) echo "Saliendo..."; exit 0 ;;
        *) echo "Opción no válida." ;;
    esac
done
