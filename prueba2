import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;

public class IpmBatchConverter {

    private static final int BLOCK_SIZE = 1014;
    private static final int DATA_PER_BLOCK = 1012;
    private static final byte PAD_40 = 0x40;

    public static void main(String[] args) {
        if (args.length < 4) {
            System.out.println("Uso: java IpmBatchConverter --input <ruta_directorio> --output <ruta_salida>");
            return;
        }

        String inputPath = null;
        String outputPath = null;

        for (int i = 0; i < args.length; i++) {
            if ("--input".equals(args[i]) && i + 1 < args.length) inputPath = args[++i];
            else if ("--output".equals(args[i]) && i + 1 < args.length) outputPath = args[++i];
        }

        if (inputPath == null || outputPath == null) {
            System.err.println("Faltan argumentos.");
            return;
        }

        try {
            File sourceDir = new File(inputPath);
            File destDir = new File(outputPath);
            
            System.out.println("Iniciando procesamiento masivo...");
            processDirectory(sourceDir, sourceDir, destDir);
            System.out.println("Proceso completado.");

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Recorre directorios recursivamente y procesa archivos
     */
    private static void processDirectory(File currentDir, File rootSrc, File rootDest) throws IOException {
        if (!currentDir.exists()) return;

        File[] files = currentDir.listFiles();
        if (files == null) return;

        for (File f : files) {
            if (f.isDirectory()) {
                processDirectory(f, rootSrc, rootDest);
            } else {
                // Calcular ruta relativa para replicar estructura
                String relativePath = rootSrc.toURI().relativize(f.toURI()).getPath();
                File destFile = new File(rootDest, relativePath + ".txt");
                
                // Crear directorios si no existen
                destFile.getParentFile().mkdirs();
                
                System.out.println("Procesando: " + f.getName() + " -> " + destFile.getName());
                convertFile(f, destFile);
            }
        }
    }

    /**
     * Logica principal de conversion de un solo archivo
     */
    private static void convertFile(File input, File output) {
        try {
            byte[] raw = Files.readAllBytes(input.toPath());

            // 1. Detectar y remover blocking 1014 de Mastercard
            byte[] vbs = isBlocked(raw) ? remove1014Blocking(raw) : raw;

            // 2. Parsear registros RDW (Variable Record Length)
            List<byte[]> records = parseVbsRecords(vbs);

            // 3. Escribir salida en formato Hibrido (Texto + {HEX})
            // Usamos UTF-8 para que soporte los corchetes y caracteres normales
            try (BufferedWriter writer = new BufferedWriter(
                    new OutputStreamWriter(new FileOutputStream(output), "UTF-8"))) {
                
                Charset ebcdic = Charset.forName("Cp500");

                for (byte[] rec : records) {
                    writer.write(toHybridHex(rec, ebcdic));
                    writer.write("\n");
                }
            }

        } catch (Exception e) {
            System.err.println("Error convirtiendo " + input.getName() + ": " + e.getMessage());
        }
    }

    /**
     * CONVERSION CLAVE: Texto visible o {HEX} para binarios
     */
    private static String toHybridHex(byte[] bytes, Charset cs) {
        String text = new String(bytes, cs);
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < bytes.length; i++) {
            char c = text.charAt(i);
            // Si es legible (Letras, numeros, simbolos basicos ASCII 32-126)
            if (c >= 32 && c <= 126) {
                sb.append(c);
            } else {
                // Si es binario/control, imprimir byte original en HEX
                sb.append(String.format("{%02X}", bytes[i]));
            }
        }
        return sb.toString();
    }

    // --- UTILIDADES DE PARSEO (Mantenidas para leer correctamente el IPM) ---

    private static List<byte[]> parseVbsRecords(byte[] vbs) {
        List<byte[]> records = new ArrayList<>();
        int pos = 0;
        while (pos + 4 <= vbs.length) {
            int len = ((vbs[pos] & 0xFF) << 24) | ((vbs[pos+1] & 0xFF) << 16) | 
                      ((vbs[pos+2] & 0xFF) << 8) | (vbs[pos+3] & 0xFF);
            pos += 4;
            if (len == 0) break; // EOF
            if (pos + len > vbs.length) len = vbs.length - pos; // Safety
            
            byte[] rec = new byte[len];
            System.arraycopy(vbs, pos, rec, 0, len);
            records.add(rec);
            pos += len;
        }
        return records;
    }

    private static boolean isBlocked(byte[] raw) {
        if (raw.length % BLOCK_SIZE != 0) return false;
        // Check rapido: si el ultimo bloque termina en padding 0x40 0x40
        int last = raw.length;
        return raw.length >= 2 && raw[last-1] == PAD_40 && raw[last-2] == PAD_40;
    }

    private static byte[] remove1014Blocking(byte[] raw) {
        ByteArrayOutputStream out = new ByteArrayOutputStream(raw.length);
        int pos = 0;
        while (pos < raw.length) {
            int rem = raw.length - pos;
            int take = Math.min(rem, BLOCK_SIZE);
            // Tomamos 1012 datos (o lo que quede) ignorando los ultimos 2 bytes de padding si es bloque completo
            int dataLen = (take == BLOCK_SIZE) ? DATA_PER_BLOCK : take;
            out.write(raw, pos, dataLen);
            pos += take;
        }
        return out.toByteArray();
    }
}
