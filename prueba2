import java.io.*;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;

/**
 * IpmConverter - Conversor de Archivos Mastercard EBCDIC <-> ASCII
 * 
 * ARQUITECTURA:
 * 
 * Este conversor maneja dos tipos de archivos de Mastercard:
 * 
 * 1. ARCHIVOS IPM (Interchange Processing Messages):
 *    - R111, R119, T112, T120, RSP1, RSP3
 *    - Estructura: RDW (4 bytes) + VBS + 1014-blocking
 *    - Usan metodos: encodeIpm() / decodeIpm()
 * 
 * 2. ARCHIVOS DE REPORTE (Reports):
 *    - T007, T113, T121, T140, T150, T067, T068, T167, T168
 *    - Estructura: EBCDIC plano sin RDW
 *    - Usan metodos: encode() / decode()
 * 
 * CODIFICACION:
 * - EBCDIC Cp500 (IBM International EBCDIC)
 * - 1014-blocking: [1012 datos][2 padding 0x40]
 * - 0x40 = espacio en EBCDIC
 * 
 * @author Sistema de Integracion Mastercard
 * @version 3.0
 * @since 2025
 */
public class IpmConverter {

    // Constantes del layout 1014 segun especificacion Mastercard
    private static final int BLOCK_SIZE = 1014;      // Tamano total del bloque fisico
    private static final int DATA_PER_BLOCK = 1012;  // Datos utiles por bloque (1014 - 2)
    private static final byte PAD_40 = 0x40;         // Padding EBCDIC space

    // Flag de debug
    private static final boolean DEBUG = Boolean.getBoolean("ipm.debug");

    /* ========================================================================
     * MAIN - Punto de entrada
     * ======================================================================== */

    public static void main(String[] args) {
        if (args.length == 0 || "help".equalsIgnoreCase(args[0])) {
            printHelp();
            return;
        }
        
        String cmd = args[0].toLowerCase();

        try {
            // Parsear parametros UNA SOLA VEZ
            Params p = parseParams(args);
            
            // Ejecutar comando con parametros ya parseados
            if ("encodeipm".equals(cmd)) {
                runEncodeIpm(p.input, p.output);
            } else if ("decodeipm".equals(cmd)) {
                runDecodeIpm(p.input, p.output);
            } else if ("encode".equals(cmd)) {
                runEncode(p.input, p.output);
            } else if ("decode".equals(cmd)) {
                runDecode(p.input, p.output);
            } else {
                System.err.println("Comando no reconocido: " + cmd);
                printHelp();
                System.exit(2);
            }
        } catch (Exception e) {
            System.err.println("ERROR: " + e.getMessage());
            if (DEBUG) {
                e.printStackTrace();
            }
            System.exit(1);
        }
    }

    /* ========================================================================
     * COMANDOS IPM - Para archivos con estructura RDW (R111, R119, T112, T120)
     * ======================================================================== */

    /**
     * ENCODEIPM - Convierte archivo ASCII a formato IPM
     * 
     * @param inputFile Path del archivo ASCII de entrada
     * @param outputFile Path del archivo IPM de salida
     * @throws Exception Si la codificacion falla
     */
    private static void runEncodeIpm(String inputFile, String outputFile) throws Exception {
        if (DEBUG) {
            System.out.println("==============================================");
            System.out.println("ENCODEIPM - ASCII to IPM");
            System.out.println("==============================================");
        }

        System.out.println("Archivo entrada: " + inputFile);
        
        // PASO 1: Leer lineas ASCII
        List<String> lines = readLinesAscii(new File(inputFile));
        System.out.println("Lineas leidas  : " + lines.size());

        // PASO 2: Convertir a EBCDIC y construir registros
        Charset ebcdic = pickCp500();
        List<byte[]> records = new ArrayList<byte[]>();
        
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            if (line.length() == 0) continue;
            
            byte[] rec = line.getBytes(ebcdic);
            records.add(rec);
            
            if (DEBUG && i < 3) {
                System.out.println("DEBUG: Line " + (i+1) + " -> " + rec.length + " bytes EBCDIC");
            }
        }

        System.out.println("Registros      : " + records.size());

        // PASO 3: Construir VBS con RDW
        byte[] vbs = buildVbsWithRdw(records);

        // PASO 4: Aplicar 1014-blocking
        byte[] blocked = apply1014Blocking(vbs);

        System.out.println("Tamano VBS     : " + vbs.length + " bytes");
        System.out.println("Tamano blocked : " + blocked.length + " bytes");

        // PASO 5: Escribir archivo
        writeAllBytes(new File(outputFile), blocked);

        System.out.println("\nENCODEIPM completado exitosamente.");
        System.out.println("Archivo salida: " + outputFile);
    }

    /**
     * DECODEIPM - Convierte archivo IPM a formato ASCII
     * 
     * @param inputFile Path del archivo IPM de entrada
     * @param outputFile Path del archivo ASCII de salida
     * @throws Exception Si la decodificacion falla
     */
    private static void runDecodeIpm(String inputFile, String outputFile) throws Exception {
        if (DEBUG) {
            System.out.println("==============================================");
            System.out.println("DECODEIPM - IPM to ASCII");
            System.out.println("==============================================");
        }

        // PASO 1: Leer archivo completo
        byte[] raw = readAllBytes(new File(inputFile));
        System.out.println("Archivo entrada: " + inputFile);
        System.out.println("Tamano         : " + raw.length + " bytes");

        if (DEBUG) {
            System.out.println("Primeros 32 bytes: " + hexBytes(raw, 0, Math.min(32, raw.length)));
        }

        // PASO 2: Auto-detectar y remover 1014-blocking
        boolean isBlocked = detect1014Blocking(raw);
        System.out.println("1014-blocked   : " + isBlocked);
        
        byte[] vbs = isBlocked ? remove1014Blocking(raw) : raw;

        // PASO 3: Parsear RDW y extraer registros
        List<byte[]> records = parseVbsWithRdw(vbs);
        System.out.println("Registros      : " + records.size());

        // PASO 4: Convertir a ASCII
        Charset ebcdic = pickCp500();
        System.out.println("Encoding       : " + ebcdic.displayName());

        BufferedWriter writer = new BufferedWriter(
            new OutputStreamWriter(new FileOutputStream(outputFile), "UTF-8"));
        
        try {
            for (int i = 0; i < records.size(); i++) {
                byte[] rec = records.get(i);
                
                if (DEBUG && i < 3) {
                    System.out.println("DEBUG: Record " + (i+1) + " = " + rec.length + " bytes");
                }
                
                // Conversion directa EBCDIC -> ASCII
                String asciiText = new String(rec, ebcdic);
                writer.write(asciiText);
                writer.newLine();
            }
        } finally {
            writer.close();
        }

        System.out.println("\nDECODEIPM completado exitosamente.");
        System.out.println("Archivo salida: " + outputFile);
    }

    /* ========================================================================
     * COMANDOS GENERICOS - Para archivos EBCDIC planos (T007, T113, T140, T150)
     * ======================================================================== */

    /**
     * ENCODE - Convierte archivo ASCII a EBCDIC plano
     * 
     * @param inputFile Path del archivo ASCII de entrada
     * @param outputFile Path del archivo EBCDIC de salida
     * @throws Exception Si la codificacion falla
     */
    private static void runEncode(String inputFile, String outputFile) throws Exception {
        if (DEBUG) {
            System.out.println("==============================================");
            System.out.println("ENCODE - ASCII to EBCDIC");
            System.out.println("==============================================");
        }

        System.out.println("Archivo entrada: " + inputFile);

        // PASO 1: Leer archivo ASCII
        byte[] asciiData = readAllBytes(new File(inputFile));
        System.out.println("Tamano ASCII   : " + asciiData.length + " bytes");

        // PASO 2: Convertir a EBCDIC
        Charset ebcdic = pickCp500();
        String text = new String(asciiData, "UTF-8");
        byte[] ebcdicData = text.getBytes(ebcdic);
        
        System.out.println("Tamano EBCDIC  : " + ebcdicData.length + " bytes");

        // PASO 3: Aplicar 1014-blocking
        byte[] blocked = apply1014Blocking(ebcdicData);
        System.out.println("Tamano blocked : " + blocked.length + " bytes");

        // PASO 4: Escribir archivo
        writeAllBytes(new File(outputFile), blocked);

        System.out.println("\nENCODE completado exitosamente.");
        System.out.println("Archivo salida: " + outputFile);
    }

    /**
     * DECODE - Convierte archivo EBCDIC plano a ASCII
     * 
     * @param inputFile Path del archivo EBCDIC de entrada
     * @param outputFile Path del archivo ASCII de salida
     * @throws Exception Si la decodificacion falla
     */
    private static void runDecode(String inputFile, String outputFile) throws Exception {
        if (DEBUG) {
            System.out.println("==============================================");
            System.out.println("DECODE - EBCDIC to ASCII");
            System.out.println("==============================================");
        }

        // PASO 1: Leer archivo completo
        byte[] raw = readAllBytes(new File(inputFile));
        System.out.println("Archivo entrada: " + inputFile);
        System.out.println("Tamano         : " + raw.length + " bytes");

        if (DEBUG) {
            System.out.println("Primeros 32 bytes: " + hexBytes(raw, 0, Math.min(32, raw.length)));
        }

        // PASO 2: Auto-detectar y remover 1014-blocking
        boolean isBlocked = detect1014Blocking(raw);
        System.out.println("1014-blocked   : " + isBlocked);
        
        byte[] ebcdicData = isBlocked ? remove1014Blocking(raw) : raw;

        // PASO 3: Convertir a ASCII
        Charset ebcdic = pickCp500();
        System.out.println("Encoding       : " + ebcdic.displayName());
        
        String asciiText = new String(ebcdicData, ebcdic);

        // PASO 4: Escribir archivo
        FileOutputStream fos = new FileOutputStream(outputFile);
        try {
            fos.write(asciiText.getBytes("UTF-8"));
        } finally {
            fos.close();
        }

        System.out.println("\nDECODE completado exitosamente.");
        System.out.println("Archivo salida: " + outputFile);
    }

    /* ========================================================================
     * ESTRUCTURA RDW - Construccion y parseo
     * ======================================================================== */

    /**
     * Construye estructura VBS con RDW de 4 bytes Big-Endian
     */
    private static byte[] buildVbsWithRdw(List<byte[]> records) throws IOException {
        ByteArrayOutputStream vbs = new ByteArrayOutputStream();
        
        for (int i = 0; i < records.size(); i++) {
            byte[] rec = records.get(i);
            int len = rec.length;
            
            if (DEBUG && i < 3) {
                System.out.println("DEBUG: RDW para record " + (i+1) + " = " + len);
            }
            
            // Escribir RDW (4 bytes Big-Endian)
            vbs.write((len >>> 24) & 0xFF);
            vbs.write((len >>> 16) & 0xFF);
            vbs.write((len >>> 8)  & 0xFF);
            vbs.write(len & 0xFF);
            
            // Escribir payload
            vbs.write(rec);
        }
        
        // Escribir EOF
        if (DEBUG) {
            System.out.println("DEBUG: Escribiendo EOF");
        }
        vbs.write(0);
        vbs.write(0);
        vbs.write(0);
        vbs.write(0);
        
        return vbs.toByteArray();
    }

    /**
     * Parsea estructura VBS con RDW de 4 bytes Big-Endian
     */
    private static List<byte[]> parseVbsWithRdw(byte[] vbs) throws IOException {
        List<byte[]> records = new ArrayList<byte[]>();
        int pos = 0;
        int recordNum = 0;

        while (pos + 4 <= vbs.length) {
            // Leer RDW (4 bytes Big-Endian)
            int len = ((vbs[pos] & 0xFF) << 24) |
                      ((vbs[pos + 1] & 0xFF) << 16) |
                      ((vbs[pos + 2] & 0xFF) << 8) |
                      (vbs[pos + 3] & 0xFF);
            
            if (DEBUG && recordNum < 3) {
                System.out.println("DEBUG: Pos " + pos + " RDW=" + len);
            }

            // Detectar EOF
            if (len == 0) {
                if (DEBUG) {
                    System.out.println("DEBUG: EOF en pos " + pos);
                }
                break;
            }

            // Validar longitud
            if (len < 0 || len > 100000) {
                throw new IOException("RDW invalido en pos " + pos + ": " + len);
            }

            pos += 4;
            
            // Extraer payload
            if (pos + len > vbs.length) {
                throw new IOException("Payload truncado en pos " + pos);
            }
            
            byte[] payload = new byte[len];
            System.arraycopy(vbs, pos, payload, 0, len);
            records.add(payload);
            
            pos += len;
            recordNum++;
        }

        return records;
    }

    /* ========================================================================
     * 1014-BLOCKING - Deteccion, aplicacion y remocion
     * ======================================================================== */

    /**
     * Detecta si el archivo tiene 1014-blocking aplicado
     */
    private static boolean detect1014Blocking(byte[] raw) {
        if (raw.length % BLOCK_SIZE != 0) {
            if (DEBUG) {
                System.out.println("DEBUG: No es multiplo de 1014 -> NO blocked");
            }
            return false;
        }
        
        int blocks = raw.length / BLOCK_SIZE;
        if (blocks == 0) return false;

        // Contar bloques con padding
        int hits = 0;
        for (int b = 0; b < blocks; b++) {
            int end = (b + 1) * BLOCK_SIZE;
            if (raw[end - 2] == PAD_40 && raw[end - 1] == PAD_40) {
                hits++;
            }
        }
        
        if (DEBUG) {
            System.out.println("DEBUG: Bloques con 0x40 0x40: " + hits + "/" + blocks);
        }

        // Criterio: >60% de bloques con padding
        boolean result = (hits * 100 / blocks) >= 60;
        
        if (DEBUG) {
            System.out.println("DEBUG: Porcentaje: " + (hits * 100 / blocks) + "% -> " + 
                (result ? "BLOCKED" : "NO BLOCKED"));
        }
        
        return result;
    }

    /**
     * Remueve 1014-blocking de los datos
     */
    private static byte[] remove1014Blocking(byte[] raw) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream(raw.length);
        int pos = 0;
        int blockNum = 0;
        
        while (pos < raw.length) {
            int remaining = raw.length - pos;
            
            if (remaining >= BLOCK_SIZE) {
                // Bloque completo: extraer 1012 bytes
                out.write(raw, pos, DATA_PER_BLOCK);
                pos += BLOCK_SIZE;
                blockNum++;
                
                if (DEBUG && blockNum <= 3) {
                    System.out.println("DEBUG: Bloque " + blockNum + " -> 1012 bytes extraidos");
                }
            } else {
                // Bloque parcial final
                int take = Math.min(remaining, DATA_PER_BLOCK);
                if (take > 0) {
                    out.write(raw, pos, take);
                    if (DEBUG) {
                        System.out.println("DEBUG: Bloque final -> " + take + " bytes");
                    }
                }
                pos += remaining;
            }
        }
        
        return out.toByteArray();
    }

    /**
     * Aplica 1014-blocking a los datos
     */
    private static byte[] apply1014Blocking(byte[] data) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream(
            data.length + (data.length / DATA_PER_BLOCK + 1) * 2);
        
        int pos = 0;
        int blockNum = 0;
        
        while (pos < data.length) {
            int remaining = data.length - pos;
            int take = Math.min(remaining, DATA_PER_BLOCK);

            // Escribir datos disponibles
            out.write(data, pos, take);
            pos += take;
            blockNum++;

            // Padding hasta completar 1012 bytes
            if (take < DATA_PER_BLOCK) {
                for (int i = 0; i < (DATA_PER_BLOCK - take); i++) {
                    out.write(PAD_40);
                }
                if (DEBUG) {
                    System.out.println("DEBUG: Bloque " + blockNum + 
                        " con padding: " + (DATA_PER_BLOCK - take) + " bytes");
                }
            }
            
            // Trailer del bloque (SIEMPRE 2 bytes 0x40)
            out.write(PAD_40);
            out.write(PAD_40);
        }
        
        if (DEBUG) {
            System.out.println("DEBUG: Total bloques generados: " + blockNum);
        }
        
        return out.toByteArray();
    }

    /* ========================================================================
     * UTILIDADES - Charset, I/O, parsing
     * ======================================================================== */

    /**
     * Obtiene charset EBCDIC Cp500
     */
    private static Charset pickCp500() {
        try {
            return Charset.forName("Cp500");
        } catch (Exception e) {
            try {
                return Charset.forName("IBM500");
            } catch (Exception ex) {
                throw new RuntimeException("EBCDIC Cp500 charset no disponible");
            }
        }
    }

    /**
     * Lee archivo completo en memoria
     */
    private static byte[] readAllBytes(File f) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream((int) f.length());
        FileInputStream fis = new FileInputStream(f);
        try {
            byte[] buf = new byte[8192];
            int n;
            while ((n = fis.read(buf)) > 0) {
                baos.write(buf, 0, n);
            }
        } finally {
            fis.close();
        }
        return baos.toByteArray();
    }

    /**
     * Escribe bytes a archivo
     */
    private static void writeAllBytes(File f, byte[] data) throws IOException {
        FileOutputStream fos = new FileOutputStream(f);
        try {
            fos.write(data);
        } finally {
            fos.close();
        }
    }

    /**
     * Lee archivo de texto linea por linea
     */
    private static List<String> readLinesAscii(File f) throws IOException {
        List<String> lines = new ArrayList<String>();
        BufferedReader reader = new BufferedReader(
            new InputStreamReader(new FileInputStream(f), "UTF-8"));
        try {
            String line;
            while ((line = reader.readLine()) != null) {
                lines.add(line);
            }
        } finally {
            reader.close();
        }
        return lines;
    }

    /**
     * Convierte bytes a hex para debug
     */
    private static String hexBytes(byte[] data, int offset, int length) {
        StringBuilder sb = new StringBuilder();
        for (int i = offset; i < offset + length && i < data.length; i++) {
            sb.append(String.format("%02X ", data[i] & 0xFF));
        }
        return sb.toString().trim();
    }

    /**
     * Parsea parametros de linea de comandos
     */
    private static Params parseParams(String[] args) {
        Params p = new Params();
        
        for (int i = 1; i < args.length; i++) {
            String arg = args[i];
            if ("--input".equals(arg) && i + 1 < args.length) {
                p.input = args[++i];
            } else if ("--output".equals(arg) && i + 1 < args.length) {
                p.output = args[++i];
            } else {
                throw new IllegalArgumentException("Flag desconocida: " + arg);
            }
        }
        
        if (p.input == null || p.output == null) {
            throw new IllegalArgumentException("Faltan parametros --input y/o --output");
        }
        
        return p;
    }

    /**
     * Clase para parametros
     */
    private static class Params {
        String input;
        String output;
    }

    /* ========================================================================
     * AYUDA
     * ======================================================================== */

    private static void printHelp() {
        System.out.println("=================================================================");
        System.out.println("IpmConverter v3.0 - Conversor Mastercard EBCDIC <-> ASCII");
        System.out.println("=================================================================");
        System.out.println();
        System.out.println("COMANDOS:");
        System.out.println();
        System.out.println("1. ENCODEIPM - Codificar ASCII a IPM (con RDW)");
        System.out.println("   java IpmConverter encodeipm --input <txt> --output <ipm>");
        System.out.println();
        System.out.println("   Para: R111, R119, RSP1, RSP3");
        System.out.println("   - Lee archivo ASCII (un registro por linea)");
        System.out.println("   - Construye RDW de 4 bytes por registro");
        System.out.println("   - Agrega EOF (0x00000000)");
        System.out.println("   - Aplica 1014-blocking");
        System.out.println();
        System.out.println("2. DECODEIPM - Decodificar IPM a ASCII (con RDW)");
        System.out.println("   java IpmConverter decodeipm --input <ipm> --output <txt>");
        System.out.println();
        System.out.println("   Para: T112, T120");
        System.out.println("   - Auto-detecta y remueve 1014-blocking");
        System.out.println("   - Parsea RDW para extraer registros");
        System.out.println("   - Convierte EBCDIC a ASCII");
        System.out.println("   - Genera un registro por linea");
        System.out.println();
        System.out.println("3. ENCODE - Codificar ASCII a EBCDIC plano (sin RDW)");
        System.out.println("   java IpmConverter encode --input <txt> --output <ebc>");
        System.out.println();
        System.out.println("   Para: Archivos de reporte");
        System.out.println("   - Conversion directa ASCII -> EBCDIC");
        System.out.println("   - Aplica 1014-blocking");
        System.out.println("   - NO usa estructura RDW");
        System.out.println();
        System.out.println("4. DECODE - Decodificar EBCDIC plano a ASCII (sin RDW)");
        System.out.println("   java IpmConverter decode --input <ebc> --output <txt>");
        System.out.println();
        System.out.println("   Para: T007, T113, T121, T140, T150, T067, T068, T167, T168");
        System.out.println("   - Auto-detecta y remueve 1014-blocking");
        System.out.println("   - Conversion directa EBCDIC -> ASCII");
        System.out.println("   - NO parsea RDW");
        System.out.println();
        System.out.println("DEBUG:");
        System.out.println("  java -Dipm.debug=true IpmConverter <comando> ...");
        System.out.println();
        System.out.println("EJEMPLOS:");
        System.out.println();
        System.out.println("  # Codificar para envio IPM");
        System.out.println("  java IpmConverter encodeipm --input datos.txt --output R119.ipm");
        System.out.println();
        System.out.println("  # Decodificar respuesta IPM");
        System.out.println("  java IpmConverter decodeipm --input T112.ipm --output respuesta.txt");
        System.out.println();
        System.out.println("  # Decodificar reporte T150");
        System.out.println("  java IpmConverter decode --input T150.ipm --output reporte.txt");
        System.out.println();
        System.out.println("  # Codificar reporte generico");
        System.out.println("  java IpmConverter encode --input datos.txt --output salida.ebc");
        System.out.println();
        System.out.println("REFERENCIAS:");
        System.out.println("  - GCMS Reference Manual (mc_gcms.pdf)");
        System.out.println("  - EBCDIC: Cp500 (IBM International)");
        System.out.println("  - 1014-blocking: [1012 datos][2 padding 0x40]");
        System.out.println("=================================================================");
    }
}
