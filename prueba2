/*
 * #Sistema     : SWITCH ATM
 * #Subsistema  : Interface
 * #Nombre      : gentabcard
 * #Descripcion : Generacion del archivo Tabcard.txt
 * #Autor       : Cesar Mesta - SES
 * #Fecha       : 09-10-2023
 * #Modificado  : Paralelizacion con fork()
 *
 * USO:
 *   ./gentabcard           -> Comportamiento original (sin paralelizar)
 *   ./gentabcard 4         -> Paraleliza en 4 procesos
 *   ./gentabcard 8         -> Paraleliza en 8 procesos
 */

#include <stdio.h>
#include <sys/wait.h>
#include "pt_master.h"

/*Declaracion de parrafos o funciones*/
static int read_card();
static void hot_exit(int n);
static void print_card_info();
static void abrir_archivo();
static int contar_registros();

/* Declaracion de Variables*/
char pan[50];
char tracking;
char offset[13];
char pin_offset[5];
char useoffset;
char date_cp[9];
char embossing[107];
char birthdate[11];
char expdate[5];

/*Para obtener la Hora del sistema*/
time_t now;

extern char *argv0;

FILE *fp;       /* Declaracion de archivo*/

/* Variables para paralelizacion */
int g_offset = 0;
int g_cantidad = 0;
int g_proceso_id = -1;  /* -1 = modo original, >=0 = modo paralelo */
int g_modo_paralelo = 0;

int main(int argc, char **argv, char **env)
{
    int num_procesos = 0;
    int total_registros;
    int chunk;
    int i;
    pid_t pid;
    int status;
    
    system("clear");
    printf("%s \n", " Generacion de Archivo Tabcard ");
    
    /* Verificar si se pide modo paralelo */
    if (argc >= 2) {
        num_procesos = atoi(argv[1]);
        if (num_procesos < 1 || num_procesos > 16) {
            printf("Error: numero de procesos debe ser entre 1 y 16\n");
            printf("Uso: %s [num_procesos]\n", argv[0]);
            printf("  Sin parametros = modo original\n");
            printf("  Con parametro  = modo paralelo\n");
            exit(1);
        }
        g_modo_paralelo = 1;
        printf("Modo PARALELO con %d procesos\n\n", num_procesos);
    } else {
        printf("Modo ORIGINAL (sin paralelizar)\n\n");
    }
    
    sw_logon_database(1);       /* Ingreso a la BD*/
    
    /* MODO ORIGINAL - sin paralelizar */
    if (!g_modo_paralelo) {
        fep_catch_sig(0, hot_exit);
        abrir_archivo();
        read_card();
        return 0;
    }
    
    /* MODO PARALELO - con fork */
    total_registros = contar_registros();
    printf("Total de registros a procesar: %d\n", total_registros);
    
    if (total_registros == 0) {
        printf("No hay registros para procesar\n");
        exit(0);
    }
    
    chunk = (total_registros + num_procesos - 1) / num_procesos;
    printf("Registros por proceso: ~%d\n\n", chunk);
    
    /* Crear procesos hijos */
    for (i = 0; i < num_procesos; i++) {
        pid = fork();
        
        if (pid < 0) {
            perror("Error en fork");
            exit(1);
        }
        else if (pid == 0) {
            /* PROCESO HIJO */
            g_proceso_id = i;
            g_offset = i * chunk;
            g_cantidad = chunk;
            
            if (g_offset >= total_registros) {
                exit(0);
            }
            
            if (g_offset + g_cantidad > total_registros) {
                g_cantidad = total_registros - g_offset;
            }
            
            printf("[Proceso %d] Iniciando: registros %d a %d\n",
                   i, g_offset + 1, g_offset + g_cantidad);
            
            sw_logon_database(1);
            fep_catch_sig(0, hot_exit);
            abrir_archivo();
            read_card();
            
            printf("[Proceso %d] Terminado\n", g_proceso_id);
            exit(0);
        }
    }
    
    /* PROCESO PADRE: esperar a todos los hijos */
    printf("Esperando a %d procesos...\n", num_procesos);
    for (i = 0; i < num_procesos; i++) {
        wait(&status);
    }
    
    /* Unir archivos */
    printf("\nUniendo archivos...\n");
    {
        char cmd[512];
        sprintf(cmd, "cat %s/tabcard_*.txt > %s/tabcard_final.txt 2>/dev/null",
                getenv("LOGDIR"), getenv("LOGDIR"));
        system(cmd);
        
        /* Limpiar archivos temporales */
        sprintf(cmd, "rm -f %s/tabcard_[0-9]*.txt 2>/dev/null", getenv("LOGDIR"));
        system(cmd);
    }
    
    printf("\n=== COMPLETADO ===\n");
    printf("Archivo final: %s/tabcard_final.txt\n", getenv("LOGDIR"));
    
    return 0;
}

static int contar_registros()
{
    char command[300];
    ESP_SLOT slot;
    ESP_SLOTP slotp = &slot;
    int total = 0;
    char count_str[20];
    
    memset(command, '\0', sizeof(command));
    memset(count_str, '\0', sizeof(count_str));
    
    sprintf(command,
        "SELECT COUNT(*) as total FROM card "
        "WHERE (pan IS NOT NULL) "
        "AND (bin NOT IN ('890507','890502','890506','890530'))");
    
    cc_send("Count query [%s]\n", command);
    
    if (esp_read(slotp, "card", command, ESP_LOOK)) {
        cc_send("ESP_READ ERROR: [%s]", (char*)*Last_error);
        fprintf(stderr, "Error contando registros\n");
        return 0;
    }
    
    if (!esp_fetch(slotp)) {
        esp_get(slotp, "total", count_str);
        total = atoi(count_str);
    }
    
    esp_free(slotp);
    return total;
}

static void abrir_archivo()
{
    char filename[100];
    
    memset(filename, '\0', sizeof(filename));
    
    if (g_modo_paralelo) {
        /* Modo paralelo: archivo por proceso */
        sprintf(filename, "%s/tabcard_%02d.txt", getenv("LOGDIR"), g_proceso_id);
    } else {
        /* Modo original: archivo unico */
        sprintf(filename, "%s/tabcard.txt", getenv("LOGDIR"));
    }
    
    fp = fopen(filename, "w");
    if (fp == NULL)
    {
        printf("Could not open file %s\n", filename);
        fclose(fp);
        exit(1);
    }
}

static void print_card_info()
{
    char record[300], *p;
    
    memset(record, 0, sizeof(record));
    p = record;
    p += sprintf(p, "%-19s", pan);
    p += sprintf(p, " ");  //Fille 1
    p += sprintf(p, "%c", tracking);
    p += sprintf(p, " ");  //Fille 2
    p += sprintf(p, "%-12s", offset);
    p += sprintf(p, " ");  //Fille 3
    p += sprintf(p, "%-4s", pin_offset);
    p += sprintf(p, " ");  //Fille 4
    p += sprintf(p, "%c", useoffset);
    p += sprintf(p, " ");  //Fille 5
    p += sprintf(p, "%-8s", date_cp);
    p += sprintf(p, " ");  //Fille 6
    p += sprintf(p, "%-28s", embossing);
    p += sprintf(p, " ");  //Fille 7
    p += sprintf(p, "%-10s", birthdate);
    p += sprintf(p, " ");  //Fille 8
    p += sprintf(p, "%-4s", expdate);
    
    fprintf(fp, "%s \n", record);
    fflush(fp);
    free(p);
    free(record);
}

static int read_card()
{
    char command[600];
    int cnttmp = 0;
    int cnttotal = 0;
    int tope = 4;
    char enc_wall;
    ESP_SLOT slot;
    ESP_SLOTP slotp = &slot;
    
    memset(command, '\0', sizeof(command));
    
    if (g_modo_paralelo) {
        /* Query con paginacion para modo paralelo */
        sprintf(command,
            "SELECT * FROM ("
            "  SELECT a.*, ROWNUM rn FROM ("
            "    SELECT * FROM card "
            "    WHERE (pan IS NOT NULL) "
            "    AND (bin NOT IN ('890507','890502','890506','890530')) "
            "    ORDER BY rowid"
            "  ) a WHERE ROWNUM <= %d"
            ") WHERE rn > %d",
            g_offset + g_cantidad,
            g_offset);
    } else {
        /* Query original */
        sprintf(command,
            "SELECT * FROM card "
            "WHERE (pan IS NOT NULL) "
            "AND (bin NOT IN ('890507','890502','890506','890530')) "
            "ORDER BY rowid");
    }
    
    cc_send("Comand [%s]\n", command);
    
    if (esp_read(slotp, "card", command, ESP_LOOK))
    {
        cc_send("ESP_READ ERROR: [%s]", (char*)*Last_error);
        fprintf(stderr, "Can't read CARD Table!: %s\n", (char*)*Last_error);
        exit(1);
    }
    
    while (!esp_fetch(slotp))
    {
        cnttmp++;
        cnttotal++;
        
        enc_wall = 'N';
        tracking = 'H';
        useoffset = 'N';
        
        memset(pan, '\0', sizeof(pan));
        memset(offset, '\0', sizeof(offset));
        memset(pin_offset, '\0', sizeof(pin_offset));
        memset(date_cp, '\0', sizeof(date_cp));
        memset(embossing, '\0', sizeof(embossing));
        memset(birthdate, '\0', sizeof(birthdate));
        memset(expdate, '\0', sizeof(expdate));
        
        esp_get(slotp, "tracking", tracking);
        esp_get(slotp, "offset", offset);
        esp_get(slotp, "pin_offset", pin_offset);
        esp_get(slotp, "useoffset", useoffset);
        esp_get(slotp, "date_cp", date_cp);
        esp_get(slotp, "embossing", embossing);
        esp_get(slotp, "birthdate", birthdate);
        esp_get(slotp, "exp_date", expdate);
        esp_get(slotp, "enc_wall", enc_wall);
        
        if (enc_wall == 'Y')
        {
            if (esp_get(slotp, "pan", pan, ENCTRUE))
            {
                cc_send("%s", (char*)*Last_error);
                esp_free(slotp);
                exit(1);
            }
        }
        else
        {
            esp_get(slotp, "pan", pan);
        }
        
        if (cnttmp == tope)
        {
            time(&now);
            cnttmp = 0;
        }
        
        print_card_info();
    }
    
    printf("\n");
    esp_free(slotp);
    fclose(fp);
    printf("Total de registros leidos: %d\n", cnttotal);
    
    return 0;
}

static void hot_exit(int n)
{
    printf("Cancelled with [%d]\n", n);
    esp_abort();
    exit(0);
}
