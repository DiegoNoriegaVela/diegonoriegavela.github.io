import java.io.BufferedReader;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream; 
import java.io.FileOutputStream;
import java.io.InputStreamReader; 
import java.io.IOException;

public class IsoBitmapHexToBinaryConverter {

    private static final int MTI_LENGTH = 4;
    private static final int BITMAP_HEX_LENGTH = 32; 
    private static final int TOTAL_PREFIX_LENGTH = MTI_LENGTH + BITMAP_HEX_LENGTH;

    public static void main(String[] args) {
        String inputFileBasePath = null;
        String outputFileBasePath = null;

        // 1. Leer parámetros
        for (int i = 0; i < args.length; i++) {
            if ("--input".equals(args[i]) && i + 1 < args.length) {
                inputFileBasePath = args[i + 1];
                i++;
            } else if ("--output".equals(args[i]) && i + 1 < args.length) {
                outputFileBasePath = args[i + 1];
                i++;
            }
        }

        if (inputFileBasePath == null || outputFileBasePath == null) {
            System.err.println("Error: Faltan parametros.");
            System.exit(1);
        }

        File inputFile = new File(inputFileBasePath);
        File outputFile = new File(outputFileBasePath);

        // Variables fuera del try para poder cerrarlas en el finally (Java antiguo)
        BufferedReader reader = null;
        BufferedOutputStream writer = null;

        try {
            // Leemos el archivo de entrada como ASCII puro
            reader = new BufferedReader(new InputStreamReader(new FileInputStream(inputFile), "US-ASCII"));
            writer = new BufferedOutputStream(new FileOutputStream(outputFile));

            String line;
            while ((line = reader.readLine()) != null) {
                if (line.length() < TOTAL_PREFIX_LENGTH) continue;

                try {
                    String mtiStr = line.substring(0, MTI_LENGTH);
                    String hexBitmapStr = line.substring(MTI_LENGTH, TOTAL_PREFIX_LENGTH);
                    String restOfDataStr = line.substring(TOTAL_PREFIX_LENGTH);

                    // PASO 1: Convertir el Hex (ej: "80...") a Bytes crudos (ej: 0x80)
                    byte[] rawBytes = hexStringToByteArray(hexBitmapStr);

                    // PASO 2 (LA CLAVE): Simular la conversión original de AS/400.
                    // Interpretamos esos bytes como si fueran EBCDIC (Cp1047).
                    // Esto hace que 0x80 se convierta en el caracter 'Ø'.
                    String simulatedEbcdicStr = new String(rawBytes, "Cp1047");

                    // PASO 3: Guardar ese resultado como UTF-8.
                    // Esto hace que la 'Ø' se convierta en los bytes C3 98.
                    byte[] finalOutputBytes = simulatedEbcdicStr.getBytes("UTF-8");

                    // --- ESCRITURA ---
                    writer.write(mtiStr.getBytes("US-ASCII")); // MTI
                    writer.write(finalOutputBytes);            // Bitmap (ahora será C3 98...)
                    writer.write(restOfDataStr.getBytes("US-ASCII")); // Resto
                    writer.write('\n'); // Salto de línea

                } catch (Exception e) {
                    System.err.println("Error procesando linea: " + e.getMessage());
                }
            }
            
            writer.flush();
            System.out.println("Proceso completado. Se genero el formato UTF-8 simulado.");

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (reader != null) reader.close();
                if (writer != null) writer.close();
            } catch (Exception ex) {}
        }
    }

    private static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            int digit1 = Character.digit(s.charAt(i), 16);
            int digit2 = Character.digit(s.charAt(i + 1), 16);
            if (digit1 == -1 || digit2 == -1) { digit1=0; digit2=0; }
            data[i / 2] = (byte) ((digit1 << 4) + digit2);
        }
        return data;
    }
}
