import java.io.*;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;

/**

- IpmConverter - Conversor de Archivos IPM entre formatos EBCDIC y ASCII
- 
- Herramienta especializada para convertir archivos IPM (Interchange Processing Messages)
- de Mastercard entre formato binario EBCDIC con RDW/1014-blocking y formato texto ASCII.
- 
- FORMATO DE ARCHIVO IPM (EBCDIC):
- 
- Los archivos IPM utilizan una estructura de tres capas segun el manual de Mastercard:
- 
- 1. CAPA RDW (Record Descriptor Word):
- - Campo de 4 bytes Big-Endian antes de cada mensaje IPM
- - Contiene la longitud del payload del mensaje (sin incluir los 4 bytes del RDW)
- - EOF marcado con RDW = 0x00000000
- - Permite mensajes de longitud variable
- 
- 1. CAPA VBS (Variable Blocked Spanned):
- - Formato Variable Blocked Spanned
- - Los mensajes pueden exceder el limite de 1014 bytes de la red Mastercard
- - Mensajes grandes pueden “spannear” multiples bloques
- 
- 1. CAPA 1014-BLOCKING:
- - Bloques fisicos de 1014 bytes para transmision por red Mastercard
- - Estructura: [1012 bytes datos][2 bytes padding 0x40]
- - Padding con 0x40 (espacio EBCDIC) hasta completar bloque
- - Ultimo bloque puede ser parcial con padding
- 
- CODIFICACION:
- - EBCDIC Cp500 (IBM International EBCDIC)
- - Todos los campos alfanumericos en EBCDIC
- - 0x40 = espacio en EBCDIC
- 
- MODOS DE OPERACION:
- 
- 1. DECODE (IPM binario EBCDIC -> archivo texto ASCII):
- - Lee archivo IPM con 1014-blocking
- - Auto-detecta y remueve 1014-blocking
- - Parsea RDW para extraer mensajes individuales
- - Convierte cada registro de EBCDIC a ASCII
- - Genera UN SOLO archivo de salida con un registro por linea
- - Formato de salida simple y legible
- 
- 1. ENCODE (archivo texto ASCII -> IPM binario EBCDIC):
- - Lee archivo de texto ASCII (una linea = un registro)
- - Convierte cada linea a EBCDIC Cp500
- - Construye estructura VBS con RDW de 4 bytes
- - Aplica 1014-blocking para transmision
- - Genera archivo IPM listo para envio
- 
- 1. RAW (conversion directa sin parseo RDW):
- - Conversion byte-a-byte EBCDIC <-> ASCII
- - NO parsea estructura RDW
- - NO aplica 1014-blocking
- - Util para archivos EBCDIC genericos o debugging
- - Mantiene estructura original del archivo
- 
- SALIDA SIMPLIFICADA (DECODE):
- - Archivo unico con nombre especificado en –output
- - Un registro por linea
- - Formato ASCII legible
- - Sin archivos adicionales
- 
- Referencias:
- - GCMS Reference Manual: “Record Descriptor Word at the beginning of IPM messages”
- - File Transfer Manual: “Variable Blocked Spanned (VBS) format”
- - Layout 1014: Bloques de 1014 bytes (1012 datos + 2 padding)
- 
- @author Sistema de Integracion Mastercard
- @version 2.1
- @since 2024
  */
  public class IpmConverter {
  
  // Parametros del layout 1014 segun especificacion Mastercard
  private static final int BLOCK_SIZE = 1014;      // Tamano total del bloque fisico
  private static final int DATA_PER_BLOCK = 1012;  // Datos utiles por bloque (1014 - 2)
  private static final byte PAD_40 = 0x40;         // Padding EBCDIC space (literal 0x40)
  
  // Flag de debug para diagnostico detallado
  private static final boolean DEBUG = Boolean.getBoolean(“ipm.debug”);
  
  public static void main(String[] args) {
  if (args.length == 0 || “help”.equalsIgnoreCase(args[0])) {
  printHelp();
  return;
  }
  String cmd = args[0].toLowerCase();
  
  ```
   if ("decode".equals(cmd)) {
       runDecode(args);
   } else if ("encode".equals(cmd)) {
       runEncode(args);
   } else if ("raw".equals(cmd)) {
       runRaw(args);
   } else {
       System.err.println("Comando no soportado: " + cmd);
       printHelp();
       System.exit(2);
   }
  ```
  
  }
  
  /* ========================================================================
  - MODO DECODE - Decodificacion de archivo IPM binario a texto ASCII
  - ======================================================================== */
  
  /**
  - Ejecuta el proceso de decodificacion de un archivo IPM
  - 
  - PROCESO:
  - 1. Lee archivo IPM binario completo
  - 1. Auto-detecta presencia de 1014-blocking
  - 1. Remueve 1014-blocking si existe
  - 1. Parsea estructura VBS con RDW de 4 bytes
  - 1. Extrae cada registro individual
  - 1. Convierte de EBCDIC a ASCII
  - 1. Genera UN SOLO archivo de salida:
  - - Ruta y nombre especificado en –output
  - - Un registro por linea
  - - Formato ASCII legible
  - 
  - FLAGS:
  - –input <ruta>   : Archivo IPM a decodificar (requerido)
  - –output <ruta>  : Archivo de salida (requerido)
  - 
  - SALIDA:
  - Un unico archivo de texto con todos los registros, uno por linea.
  - 
  - @param args Argumentos de linea de comandos
    */
    private static void runDecode(String[] args) {
    String inputPath = null;
    String outputPath = null;
    
    // Parseo de parametros
    for (int i = 1; i < args.length; i++) {
    String a = args[i];
    if (”–input”.equals(a) && i + 1 < args.length) {
    inputPath = args[++i];
    } else if (”–output”.equals(a) && i + 1 < args.length) {
    outputPath = args[++i];
    } else {
    System.err.println(“Flag desconocida o valor faltante: “ + a);
    printHelp();
    System.exit(2);
    }
    }
    
    if (inputPath == null || outputPath == null) {
    System.err.println(“Faltan parametros –input y/o –output”);
    printHelp();
    System.exit(2);
    }
    
    try {
    if (DEBUG) {
    System.out.println(”==============================================”);
    System.out.println(“MODO DEBUG ACTIVADO”);
    System.out.println(”==============================================”);
    }
    
    ```
     // Leer archivo completo en memoria
     byte[] raw = readAllBytes(new File(inputPath));
     System.out.println("Archivo entrada: " + inputPath);
     System.out.println("Tamano         : " + raw.length + " bytes");
    
     if (DEBUG) {
         System.out.println("Primeros 32 bytes (hex): " + hexBytes(raw, 0, Math.min(32, raw.length)));
     }
    
     // Auto-deteccion de 1014-blocking
     boolean isBlocked = decideBlockedImproved(raw);
     System.out.println("1014-blocked   : " + isBlocked);
     
     if (DEBUG && isBlocked) {
         System.out.println("DEBUG: Removiendo 1014-blocking...");
     }
    
     // Remover blocking si existe
     byte[] vbs = isBlocked ? remove1014Blocking(raw) : raw;
    
     if (DEBUG) {
         System.out.println("DEBUG: Tamano VBS: " + vbs.length + " bytes");
         System.out.println("DEBUG: Parseando registros RDW...");
     }
    
     // Parsear estructura VBS con RDW IPM (4 bytes BE)
     List<byte[]> records = parseVbsRdwIpm(vbs);
     System.out.println("Registros      : " + records.size());
    
     // Preparar charset EBCDIC para conversion
     Charset cs = pickCp500();
     System.out.println("Encoding       : " + cs.displayName());
    
     // Generar archivo de salida consolidado
     System.out.println("\nGenerando archivo de salida...");
     BufferedWriter writer = new BufferedWriter(
         new OutputStreamWriter(new FileOutputStream(outputPath), "UTF-8"));
     
     try {
         for (int i = 0; i < records.size(); i++) {
             byte[] rec = records.get(i);
             
             if (DEBUG && i < 3) {
                 System.out.println("DEBUG: Record " + (i+1) + " size=" + rec.length + 
                     " hex=" + hexBytes(rec, 0, Math.min(16, rec.length)));
             }
             
             // Convertir de EBCDIC a ASCII (conversión directa sin filtros)
             String asciiText = new String(rec, cs);
             
             // Escribir linea (un registro por linea)
             writer.write(asciiText);
             writer.newLine();
         }
     } finally {
         writer.close();
     }
    
     System.out.println("\nDECODE completado exitosamente.");
     System.out.println("Archivo salida: " + outputPath);
    ```
    
    } catch (Exception e) {
    System.err.println(“Error en DECODE: “ + e.getMessage());
    e.printStackTrace();
    System.exit(1);
    }
    }
  
  /* ========================================================================
  - MODO ENCODE - Codificacion de texto ASCII a archivo IPM binario
  - ======================================================================== */
  
  /**
  - Ejecuta el proceso de codificacion de texto ASCII a formato IPM
  - 
  - PROCESO:
  - 1. Lee archivo ASCII de entrada (una linea por registro)
  - 1. Para cada linea:
  - a. Convierte texto ASCII a EBCDIC Cp500
  - b. Construye registro VBS con RDW de 4 bytes (longitud en BE)
  - 1. Agrega EOF (0x00000000) al final
  - 1. Aplica 1014-blocking completo
  - 1. Escribe archivo IPM binario listo para transmision
  - 
  - FLAGS:
  - –input <ruta>   : Archivo texto ASCII (requerido)
  - –output <ruta>  : Archivo IPM de salida (requerido)
  - 
  - SALIDA:
  - Archivo IPM binario en formato EBCDIC con:
  - - Estructura VBS con RDW
  - - 1014-blocking aplicado
  - - EOF (0x00000000) al final
  - - Listo para enviar a Mastercard
  - 
  - @param args Argumentos de linea de comandos
    */
    private static void runEncode(String[] args) {
    String inputPath = null;
    String outputPath = null;
    
    // Parseo de parametros
    for (int i = 1; i < args.length; i++) {
    String a = args[i];
    if (”–input”.equals(a) && i + 1 < args.length) {
    inputPath = args[++i];
    } else if (”–output”.equals(a) && i + 1 < args.length) {
    outputPath = args[++i];
    } else {
    System.err.println(“Flag desconocida o valor faltante: “ + a);
    printHelp();
    System.exit(2);
    }
    }
    
    if (inputPath == null || outputPath == null) {
    System.err.println(“Faltan parametros –input y/o –output”);
    printHelp();
    System.exit(2);
    }
    
    try {
    if (DEBUG) {
    System.out.println(”==============================================”);
    System.out.println(“MODO DEBUG ACTIVADO - ENCODE”);
    System.out.println(”==============================================”);
    }
    
    ```
     // Charset EBCDIC
     Charset cs = pickCp500();
     System.out.println("Archivo entrada: " + inputPath);
     System.out.println("Encoding       : " + cs.displayName());
    
     // Leer archivo linea por linea y construir VBS
     ByteArrayOutputStream vbsOut = new ByteArrayOutputStream();
     BufferedReader reader = new BufferedReader(
         new InputStreamReader(new FileInputStream(inputPath), "UTF-8"));
     
     int recordCount = 0;
     String line;
     
     try {
         while ((line = reader.readLine()) != null) {
             recordCount++;
             
             // Convertir linea ASCII a EBCDIC
             byte[] ebcdicData = line.getBytes(cs);
             int len = ebcdicData.length;
             
             if (DEBUG && recordCount <= 3) {
                 System.out.println("DEBUG: Record " + recordCount + 
                     " ASCII_len=" + line.length() + 
                     " EBCDIC_len=" + len);
                 System.out.println("DEBUG: Primera linea ASCII: " + 
                     (line.length() > 60 ? line.substring(0, 60) + "..." : line));
                 System.out.println("DEBUG: EBCDIC hex: " + 
                     hexBytes(ebcdicData, 0, Math.min(32, ebcdicData.length)));
             }
             
             // Construir RDW: 4 bytes Big-Endian con longitud del payload
             byte[] rdw = new byte[4];
             rdw[0] = (byte) ((len >> 24) & 0xFF);
             rdw[1] = (byte) ((len >> 16) & 0xFF);
             rdw[2] = (byte) ((len >> 8) & 0xFF);
             rdw[3] = (byte) (len & 0xFF);
             
             if (DEBUG && recordCount <= 3) {
                 System.out.println("DEBUG: RDW=" + hexBytes(rdw, 0, 4) + 
                     " (len=" + len + ")");
             }
             
             // Escribir RDW + payload en VBS stream
             vbsOut.write(rdw);
             vbsOut.write(ebcdicData);
         }
     } finally {
         reader.close();
     }
    
     // Agregar EOF: 0x00000000
     vbsOut.write(new byte[]{0, 0, 0, 0});
     
     System.out.println("Registros      : " + recordCount);
     
     byte[] vbs = vbsOut.toByteArray();
     if (DEBUG) {
         System.out.println("DEBUG: VBS total size: " + vbs.length + " bytes");
     }
    
     // Aplicar 1014-blocking
     if (DEBUG) {
         System.out.println("DEBUG: Aplicando 1014-blocking...");
     }
     byte[] blocked = apply1014Blocking(vbs);
    
     System.out.println("Tamano VBS     : " + vbs.length + " bytes");
     System.out.println("Tamano blocked : " + blocked.length + " bytes");
    
     // Escribir archivo de salida
     FileOutputStream fos = new FileOutputStream(outputPath);
     try {
         fos.write(blocked);
     } finally {
         fos.close();
     }
    
     System.out.println("\nENCODE completado exitosamente.");
     System.out.println("Archivo salida: " + outputPath);
    ```
    
    } catch (Exception e) {
    System.err.println(“Error en ENCODE: “ + e.getMessage());
    e.printStackTrace();
    System.exit(1);
    }
    }
  
  /* ========================================================================
  - MODO RAW - Conversion directa EBCDIC <-> ASCII sin parseo RDW
  - ======================================================================== */
  
  /**
  - Ejecuta conversion RAW entre EBCDIC y ASCII
  - 
  - Conversion byte-a-byte sin parseo de estructura VBS ni RDW.
  - Util para archivos EBCDIC genericos o debugging.
  - NO aplica ni remueve 1014-blocking.
  - 
  - FLAGS:
  - –input <ruta>        : Archivo de entrada (requerido)
  - –output <ruta>       : Archivo de salida (requerido)
  - –direction <e2a|a2e> : Direccion de conversion (requerido)
  - e2a = EBCDIC to ASCII
  - a2e = ASCII to EBCDIC
  - 
  - @param args Argumentos de linea de comandos
    */
    private static void runRaw(String[] args) {
    String inputPath = null;
    String outputPath = null;
    String direction = null;
    
    // Parseo de parametros
    for (int i = 1; i < args.length; i++) {
    String a = args[i];
    if (”–input”.equals(a) && i + 1 < args.length) {
    inputPath = args[++i];
    } else if (”–output”.equals(a) && i + 1 < args.length) {
    outputPath = args[++i];
    } else if (”–direction”.equals(a) && i + 1 < args.length) {
    direction = args[++i].toLowerCase();
    } else {
    System.err.println(“Flag desconocida o valor faltante: “ + a);
    printHelp();
    System.exit(2);
    }
    }
    
    if (inputPath == null || outputPath == null || direction == null) {
    System.err.println(“Faltan parametros –input, –output y/o –direction”);
    printHelp();
    System.exit(2);
    }
    
    if (!“e2a”.equals(direction) && !“a2e”.equals(direction)) {
    System.err.println(”–direction debe ser ‘e2a’ o ‘a2e’”);
    printHelp();
    System.exit(2);
    }
    
    try {
    Charset cs = pickCp500();
    System.out.println(“Archivo entrada: “ + inputPath);
    System.out.println(“Direccion      : “ + direction);
    System.out.println(“Encoding       : “ + cs.displayName());
    
    ```
     byte[] raw = readAllBytes(new File(inputPath));
     System.out.println("Tamano entrada : " + raw.length + " bytes");
    
     byte[] result;
     if ("e2a".equals(direction)) {
         // EBCDIC -> ASCII (conversión directa)
         String ebcdicText = new String(raw, cs);
         result = ebcdicText.getBytes("UTF-8");
     } else {
         // ASCII -> EBCDIC
         String asciiText = new String(raw, "UTF-8");
         result = asciiText.getBytes(cs);
     }
    
     System.out.println("Tamano salida  : " + result.length + " bytes");
    
     // Escribir resultado
     FileOutputStream fos = new FileOutputStream(outputPath);
     try {
         fos.write(result);
     } finally {
         fos.close();
     }
    
     System.out.println("\nRAW conversion completada exitosamente.");
     System.out.println("Archivo salida: " + outputPath);
    ```
    
    } catch (Exception e) {
    System.err.println(“Error en RAW: “ + e.getMessage());
    e.printStackTrace();
    System.exit(1);
    }
    }
  
  /* ========================================================================
  - PARSEO VBS - Extraccion de registros con RDW
  - ======================================================================== */
  
  /**
  - Parsea datos VBS con RDW de 4 bytes Big-Endian (formato IPM)
  - 
  - Formato RDW IPM:
  - - 4 bytes Big-Endian conteniendo longitud del payload
  - - Payload de N bytes
  - - EOF marcado con 0x00000000
  - 
  - @param vbs Datos VBS sin 1014-blocking
  - @return Lista de registros extraidos
  - @throws IOException Si el formato es invalido
    */
    private static List<byte[]> parseVbsRdwIpm(byte[] vbs) throws IOException {
    List<byte[]> records = new ArrayList<byte[]>();
    int pos = 0;
    int recordNum = 0;
    
    while (pos + 4 <= vbs.length) {
    // Leer RDW de 4 bytes Big-Endian
    int rdw = ((vbs[pos] & 0xFF) << 24) |
    ((vbs[pos + 1] & 0xFF) << 16) |
    ((vbs[pos + 2] & 0xFF) << 8) |
    (vbs[pos + 3] & 0xFF);
    
    ```
     if (DEBUG && recordNum < 3) {
         System.out.println("DEBUG: Pos " + pos + " RDW=" + rdw + 
             " (hex: " + String.format("%08X", rdw) + ")");
     }
    
     // Detectar EOF (0x00000000)
     if (rdw == 0) {
         if (DEBUG) {
             System.out.println("DEBUG: EOF detectado en pos " + pos);
         }
         break;
     }
    
     // Validar longitud razonable
     if (rdw < 0 || rdw > 100000) {
         throw new IOException("RDW invalido en pos " + pos + ": " + rdw);
     }
    
     pos += 4;
     
     // Extraer payload
     if (pos + rdw > vbs.length) {
         throw new IOException("Payload truncado en pos " + pos + 
             ", necesita " + rdw + " bytes pero solo quedan " + 
             (vbs.length - pos));
     }
     
     byte[] payload = new byte[rdw];
     System.arraycopy(vbs, pos, payload, 0, rdw);
     records.add(payload);
     
     pos += rdw;
     recordNum++;
    ```
    
    }
    
    return records;
    }
  
  /* ========================================================================
  - AUTO-DETECCION Y MANEJO DE 1014-BLOCKING
  - ======================================================================== */
  
  /**
  - Auto-detecta si los datos tienen 1014-blocking aplicado
  - 
  - Criterios de deteccion:
  - 1. Tamano divisible entre 1014
  - 1. Mayoria de bloques terminan en 0x40 0x40 (padding EBCDIC)
  - 1. Padding extenso despues de EOF si existe
  - 
  - @param raw Datos a analizar
  - @return true si tiene 1014-blocking, false caso contrario
    */
    private static boolean decideBlockedImproved(byte[] raw) {
    if (raw.length == 0) {
    return false;
    }
    
    // Si no es multiplo de 1014, definitivamente no esta blocked
    if (raw.length % BLOCK_SIZE != 0) {
    if (DEBUG) {
    System.out.println(“DEBUG: Longitud “ + raw.length +
    “ no es multiplo de 1014 -> NO BLOCKED”);
    }
    return false;
    }
    
    int blocks = raw.length / BLOCK_SIZE;
    if (DEBUG) {
    System.out.println(“DEBUG: Analizando “ + blocks + “ bloques de 1014 bytes”);
    }
    
    // Contar bloques que terminan en 0x40 0x40
    int hits = 0;
    for (int b = 0; b < blocks; b++) {
    int end = (b + 1) * BLOCK_SIZE;
    if (raw[end - 2] == PAD_40 && raw[end - 1] == PAD_40) {
    hits++;
    }
    }
    
    if (DEBUG) {
    System.out.println(“DEBUG: Bloques con padding 0x40 0x40: “ + hits + “/” + blocks);
    }
    
    // Si hay multiples bloques: criterio de mayoria
    if (blocks > 1) {
    boolean result = (hits * 100 / blocks) >= 60;
    if (DEBUG) {
    System.out.println(“DEBUG: Porcentaje: “ + (hits * 100 / blocks) + “% -> “ +
    (result ? “BLOCKED” : “NO BLOCKED”));
    }
    return result;
    }
    
    // Caso especial: un solo bloque
    if (hits == 1) {
    if (DEBUG) {
    System.out.println(“DEBUG: Un bloque con padding -> BLOCKED”);
    }
    return true;
    }
    
    // Buscar EOF y analizar padding posterior
    int eof = findRdwEof(raw);
    if (eof >= 0) {
    int padCount = 0;
    int rem = raw.length - eof;
    for (int p = eof; p < raw.length; p++) {
    if (raw[p] == PAD_40) {
    padCount++;
    }
    }
    boolean result = rem > 0 && (padCount * 100 / rem) >= 80;
    if (DEBUG) {
    System.out.println(“DEBUG: EOF en pos “ + (eof-4) + “, padding despues: “ +
    padCount + “/” + rem + “ -> “ + (result ? “BLOCKED” : “NO BLOCKED”));
    }
    return result;
    }
    
    return false;
    }
  
  /**
  - Busca el EOF (0x00000000) en los datos
  - 
  - @param a Datos donde buscar EOF
  - @return Posicion despues del EOF, o -1 si no se encuentra
    */
    private static int findRdwEof(byte[] a) {
    for (int i = 0; i + 3 < a.length; i++) {
    if (a[i] == 0 && a[i+1] == 0 && a[i+2] == 0 && a[i+3] == 0) {
    return i + 4;
    }
    }
    return -1;
    }
  
  /**
  - Remueve 1014-blocking de los datos
  - 
  - @param raw Datos con 1014-blocking
  - @return Datos sin blocking (solo VBS puro)
  - @throws IOException Si ocurre error de procesamiento
    */
    private static byte[] remove1014Blocking(byte[] raw) throws IOException {
    ByteArrayOutputStream out = new ByteArrayOutputStream(raw.length);
    int pos = 0;
    int blockNum = 0;
    
    while (pos < raw.length) {
    int remaining = raw.length - pos;
    
    ```
     if (remaining >= BLOCK_SIZE) {
         // Bloque completo: tomar 1012 bytes
         out.write(raw, pos, DATA_PER_BLOCK);
         pos += BLOCK_SIZE;
         blockNum++;
         
         if (DEBUG && blockNum <= 3) {
             System.out.println("DEBUG: Bloque " + blockNum + " procesado, extraidos 1012 bytes");
         }
     } else {
         // Bloque parcial al final
         int take = remaining < DATA_PER_BLOCK ? remaining : DATA_PER_BLOCK;
         if (take > 0) {
             out.write(raw, pos, take);
             if (DEBUG) {
                 System.out.println("DEBUG: Bloque final parcial, extraidos " + take + " bytes");
             }
         }
         pos += remaining;
     }
    ```
    
    }
    
    return out.toByteArray();
    }
  
  /**
  - Aplica 1014-blocking a los datos VBS
  - 
  - @param vbs Datos VBS sin blocking
  - @return Datos con 1014-blocking aplicado
  - @throws IOException Si ocurre error de procesamiento
    */
    private static byte[] apply1014Blocking(byte[] vbs) throws IOException {
    ByteArrayOutputStream out = new ByteArrayOutputStream(
    vbs.length + (vbs.length / DATA_PER_BLOCK + 1) * 2);
    
    int pos = 0;
    int blockNum = 0;
    
    // Buscar posición del EOF (0x00000000) para determinar tipo de padding
    int eofPos = findRdwEof(vbs);
    
    while (pos < vbs.length) {
    int remaining = vbs.length - pos;
    int take = remaining < DATA_PER_BLOCK ? remaining : DATA_PER_BLOCK;
    
    ```
     // Escribir datos disponibles
     out.write(vbs, pos, take);
     int currentEndPos = pos + take;
     pos += take;
     blockNum++;
    
     // Padding hasta completar 1012 bytes
     if (take < DATA_PER_BLOCK) {
         // Determinar tipo de padding: 0x00 después de EOF, 0x40 antes
         byte padByte = (eofPos > 0 && currentEndPos >= eofPos) ? (byte)0x00 : PAD_40;
         
         for (int i = 0; i < (DATA_PER_BLOCK - take); i++) {
             out.write(padByte);
         }
         if (DEBUG) {
             System.out.println("DEBUG: Bloque " + blockNum + " con padding " + 
                 String.format("0x%02X", padByte & 0xFF) + ": " + 
                 (DATA_PER_BLOCK - take) + " bytes");
         }
     }
     
     // Trailer del bloque (2 bytes 0x40)
     out.write(PAD_40);
     out.write(PAD_40);
    ```
    
    }
    
    if (DEBUG) {
    System.out.println(“DEBUG: Total bloques 1014 generados: “ + blockNum);
    }
    
    return out.toByteArray();
    }
  
  /* ========================================================================
  - UTILIDADES DE TEXTO Y CHARSET
  - ======================================================================== */
  
  /**
  - Obtiene charset EBCDIC Cp500
  - 
  - @return Charset EBCDIC Cp500
    */
    private static Charset pickCp500() {
    try {
    return Charset.forName(“Cp500”);
    } catch (Exception e) {
    try {
    return Charset.forName(“IBM500”);
    } catch (Exception ex) {
    return Charset.forName(“Cp500”);
    }
    }
    }
  
  /**
  - Convierte string a ASCII imprimible
  - 
  - Reemplaza caracteres no imprimibles con ‘.’
  - Mantiene CR, LF, TAB y caracteres ASCII 32-126.
  - 
  - @param s String a convertir
  - @return String con solo caracteres imprimibles
    */
    private static String toAsciiPrintable(String s) {
    if (s == null) {
    return “”;
    }
    
    StringBuffer sb = new StringBuffer(s.length());
    for (int i = 0; i < s.length(); i++) {
    char c = s.charAt(i);
    if ((c >= 32 && c <= 126) || c == ‘\r’ || c == ‘\n’ || c == ‘\t’) {
    sb.append(c);
    } else {
    sb.append(’.’);
    }
    }
    return sb.toString();
    }
  
  /**
  - Convierte bytes a string hexadecimal para debug
  - 
  - @param data Array de bytes
  - @param offset Posicion inicial
  - @param length Numero de bytes a convertir
  - @return String hexadecimal
    */
    private static String hexBytes(byte[] data, int offset, int length) {
    StringBuilder sb = new StringBuilder();
    for (int i = offset; i < offset + length && i < data.length; i++) {
    sb.append(String.format(”%02X “, data[i] & 0xFF));
    }
    return sb.toString().trim();
    }
  
  /* ========================================================================
  - UTILIDADES I/O
  - ======================================================================== */
  
  /**
  - Lee archivo completo en memoria
  - 
  - @param f Archivo a leer
  - @return Contenido del archivo como array de bytes
  - @throws IOException Si ocurre error de lectura
    */
    private static byte[] readAllBytes(File f) throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream((int) f.length());
    FileInputStream fis = new FileInputStream(f);
    try {
    byte[] buf = new byte[8192];
    int n;
    while ((n = fis.read(buf)) > 0) {
    baos.write(buf, 0, n);
    }
    } finally {
    fis.close();
    }
    return baos.toByteArray();
    }
  
  /* ========================================================================
  - AYUDA Y DOCUMENTACION
  - ======================================================================== */
  
  /**
  - Muestra ayuda completa del programa
    */
    private static void printHelp() {
    System.out.println(”=================================================================”);
    System.out.println(“IpmConverter - Conversor de Archivos IPM Mastercard v2.1”);
    System.out.println(”=================================================================”);
    System.out.println();
    System.out.println(“FORMATO IPM:”);
    System.out.println(”  - EBCDIC Cp500 (IBM International EBCDIC)”);
    System.out.println(”  - RDW de 4 bytes Big-Endian por mensaje”);
    System.out.println(”  - 1014-blocking (1012 datos + 2 padding 0x40)”);
    System.out.println(”  - EOF marcado con 0x00000000”);
    System.out.println();
    System.out.println(“MODOS:”);
    System.out.println();
    System.out.println(“1. DECODE - Decodificar IPM binario a texto ASCII”);
    System.out.println(”   java IpmConverter decode –input <ipm_file> –output <txt_file>”);
    System.out.println();
    System.out.println(”   Genera UN archivo de salida con:”);
    System.out.println(”   - Un registro por linea”);
    System.out.println(”   - Formato ASCII legible”);
    System.out.println(”   - Auto-deteccion y remocion de 1014-blocking”);
    System.out.println();
    System.out.println(“2. ENCODE - Codificar texto ASCII a IPM binario”);
    System.out.println(”   java IpmConverter encode –input <txt_file> –output <ipm_file>”);
    System.out.println();
    System.out.println(”   Lee archivo ASCII donde:”);
    System.out.println(”   - Una linea = un registro IPM”);
    System.out.println(”   - Genera estructura VBS con RDW”);
    System.out.println(”   - Aplica 1014-blocking completo”);
    System.out.println(”   - Agrega EOF (0x00000000)”);
    System.out.println();
    System.out.println(“3. RAW - Conversion directa EBCDIC <-> ASCII sin RDW”);
    System.out.println(”   java IpmConverter raw –input <file> –output <file>”);
    System.out.println(”                         –direction <e2a|a2e>”);
    System.out.println();
    System.out.println(”   Conversion byte-a-byte:”);
    System.out.println(”   - e2a: EBCDIC to ASCII”);
    System.out.println(”   - a2e: ASCII to EBCDIC”);
    System.out.println(”   - NO parsea RDW ni aplica blocking”);
    System.out.println();
    System.out.println(“DEBUG:”);
    System.out.println(”  java -Dipm.debug=true IpmConverter <comando> …”);
    System.out.println();
    System.out.println(“EJEMPLOS:”);
    System.out.println(”  # Decodificar IPM recibido”);
    System.out.println(”  java IpmConverter decode –input T112IN.ipm –output decoded.txt”);
    System.out.println();
    System.out.println(”  # Codificar para envio”);
    System.out.println(”  java IpmConverter encode –input records.txt –output T140OUT.ipm”);
    System.out.println();
    System.out.println(”  # Conversion RAW para debug”);
    System.out.println(”  java IpmConverter raw –input file.ebc –output file.txt”);
    System.out.println(”                        –direction e2a”);
    System.out.println();
    System.out.println(“REFERENCIAS:”);
    System.out.println(”  - GCMS Reference Manual (mc_gcms.pdf)”);
    System.out.println(”  - File Transfer Manual (File_Transfer_Manual_-_Mastercard.pdf)”);
    System.out.println(”  - Layout 1014: 1012 bytes datos + 2 bytes padding (0x40)”);
    System.out.println(”=================================================================”);
    }
    }