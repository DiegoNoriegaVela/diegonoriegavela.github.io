#!/bin/bash
set -eou pipefail

# ==============================================================================
# SCRIPT: cryptCbcToPgp.sh
# DESCRIPCION: 1. Descarga llaves (props) via SFTP.
#              2. Descarga archivo encriptado via SFTP.
#              3. Desencripta AES-CBC, encripta PGP y mueve a NFS.
# ==============================================================================

# 1. Obtener directorio local absoluto
DIR_LOCAL="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# 2. Cargar archivo de configuracion
CONFIG_FILE="${DIR_LOCAL}/config.ini"

if [ ! -f "$CONFIG_FILE" ]; then
    echo "Error: No se encuentra el archivo de configuracion $CONFIG_FILE"
    exit 1
fi

# shellcheck source=config.ini
source "$CONFIG_FILE"

# 3. Definicion de variables y rutas
DATE_YYMMDD=$(date +'%y%m%d')

# Rutas de trabajo internas
DIR_TMP="${DIR_LOCAL}/tmp"
DIR_OUT_LOCAL="${DIR_LOCAL}/OUT"

# Archivos temporales (Localmente todos estaran en tmp)
FILE_LOCAL_IFS="${DIR_TMP}/${TEMP_PROP_FILE}"
DEC_FILE="${DIR_TMP}/${TEMP_DEC_FILE}"

# AHORA: El archivo encriptado tambien estara en TMP tras la descarga
IN_ENC_FILE="${DIR_TMP}/${REMOTE_FILE_INPUT}"

# Nombres de Salida Finales
FINAL_PGP_NAME="${OUTPUT_FILENAME_PREFIX}${DATE_YYMMDD}.txt.pgp"
FINAL_CTL_NAME="${OUTPUT_CONTROL_PREFIX}${DATE_YYMMDD}.fin"

OUT_PGP_FILE="${DIR_OUT_LOCAL}/${FINAL_PGP_NAME}"
OUT_CONTROL_FILE="${DIR_OUT_LOCAL}/${FINAL_CTL_NAME}"

# Crear directorios
mkdir -p "$DIR_TMP" "$DIR_OUT_LOCAL"

# ==============================================================================
# FUNCIONES
# ==============================================================================

log() {
    while IFS= read -r line; do
        echo "$(date +'%Y-%m-%d %H:%M:%S') - $line"
    done
}

# Funcion generica para verificar si existe un directorio remoto
check_remote_dir() {
    local dir_to_check="$1"
    echo "Verificando existencia de ruta remota: $dir_to_check ..."
    
    VERIF_REMOTE=$(sftp -i "$SFTP_KEY" -oBatchMode=yes -oStrictHostKeyChecking=no "${SFTP_USER}@${SFTP_IP}" 2>&1 <<EOF
cd $dir_to_check
exit
EOF
)
    if echo "$VERIF_REMOTE" | grep -Eqi "No such file|not found"; then
        echo "Error: El directorio remoto '$dir_to_check' no existe."
        return 1
    fi
    echo "Ruta remota verificada correctamente."
}

get_props_as400() {
    echo "--- PASO 1: Obtener Archivo de Propiedades (Llaves) ---"

    # Verificar conexion y existencia de ruta de propiedades
    check_remote_dir "$REMOTE_DIR_PROPS"

    echo "Descargando propiedades..."
    if sftp -i "$SFTP_KEY" -oBatchMode=yes -oStrictHostKeyChecking=no "${SFTP_USER}@${SFTP_IP}" <<EOF >/dev/null 2>&1
lcd $DIR_TMP
cd $REMOTE_DIR_PROPS
get $REMOTE_FILE_PROPS
bye
EOF
    then
        echo "Archivo de propiedades descargado exitosamente."
    else
        echo "Error: Fallo la descarga de $REMOTE_FILE_PROPS"
        return 1
    fi
}

get_input_file_as400() {
    echo "--- PASO 2: Obtener Archivo Encriptado (Input) ---"
    
    # Verificar existencia de ruta de datos (Input)
    check_remote_dir "$REMOTE_DIR_INPUT"

    echo "Descargando archivo de datos encriptado..."
    if sftp -i "$SFTP_KEY" -oBatchMode=yes -oStrictHostKeyChecking=no "${SFTP_USER}@${SFTP_IP}" <<EOF >/dev/null 2>&1
lcd $DIR_TMP
cd $REMOTE_DIR_INPUT
get $REMOTE_FILE_INPUT
bye
EOF
    then
        echo "Archivo de datos ($REMOTE_FILE_INPUT) descargado exitosamente en TMP."
    else
        echo "Error: Fallo la descarga del archivo de datos $REMOTE_FILE_INPUT"
        return 1
    fi
}

obtener_key_iv() {
    echo "--- PASO 3: Extraccion de KEY e IV ---"

    if [ ! -f "$FILE_LOCAL_IFS" ]; then
        echo "Error: No existe el archivo de propiedades en TMP."
        return 1
    fi

    KEY_AES=$(sed -n '1p' "$FILE_LOCAL_IFS" | tr -d '\n\r ')
    IV_AES=$(sed -n '2p' "$FILE_LOCAL_IFS" | tr -d '\n\r ')

    if [ -z "$KEY_AES" ] || [ -z "$IV_AES" ]; then
        echo "Error: Datos de KEY o IV invalidos."
        return 1
    fi
    echo "Credenciales de cifrado obtenidas."
}

desencriptar_archivo() {
    echo "--- PASO 4: Desencriptado AES ---"

    if [ ! -f "$IN_ENC_FILE" ]; then
        echo "Error: No se encuentra el archivo encriptado descargado: $IN_ENC_FILE"
        return 1
    fi

    openssl enc -d -aes-256-cbc -K "$KEY_AES" -iv "$IV_AES" -in "$IN_ENC_FILE" -out "$DEC_FILE"

    if [ $? -eq 0 ]; then
        echo "Desencriptado exitoso. Generado: $DEC_FILE"
    else
        echo "Error: Fallo openssl."
        return 1
    fi
}

encriptar_archivo_pgp() {
    echo "--- PASO 5: Encriptado PGP ---"

    "$PGP_BIN" --encrypt --recipient "$PGP_RECIPIENT" --input "$DEC_FILE" --output "$OUT_PGP_FILE" --always-trust

    if [ $? -eq 0 ]; then
        echo "Encriptado PGP exitoso."
    else
        echo "Error en PGP."
        return 1
    fi
}

genera_control() {
    echo "--- PASO 6: Generacion de Control ---"
    local count
    count=$(wc -l < "$DEC_FILE")
    count=$(echo "$count" | xargs)
    echo "Registros: $count" > "$OUT_CONTROL_FILE"
    echo "Control generado con $count registros."
}

transferir_y_limpiar_nfs() {
    echo "--- PASO 7: Transferencia a NFS ---"

    if [ ! -d "$PATH_NFS_OUT" ]; then
        echo "Error: Directorio NFS no accesible: $PATH_NFS_OUT"
        return 1
    fi

    echo "Limpiando NFS destino..."
    rm -f "${PATH_NFS_OUT:?}"/*

    echo "Copiando archivos..."
    cp "$OUT_PGP_FILE" "$PATH_NFS_OUT"
    cp "$OUT_CONTROL_FILE" "$PATH_NFS_OUT"

    if [ $? -eq 0 ]; then
        echo "Archivos copiados a NFS correctamente."
    else
        echo "Error al copiar a NFS."
        return 1
    fi
}

limpiar_temporales() {
    echo "Limpiando directorio TMP..."
    rm -rf "$DIR_TMP"
}

# ==============================================================================
# MAIN
# ==============================================================================

main() {
    echo "=== INICIO PROCESO EN $(hostname) ==="

    # Secuencia de pasos
    get_props_as400        # Descarga llaves
    get_input_file_as400   # Descarga el archivo .enc (NUEVO PASO)
    obtener_key_iv         # Lee las llaves
    desencriptar_archivo   # Desencripta el archivo descargado
    encriptar_archivo_pgp  # Encripta a PGP
    genera_control         # Crea archivo control
    transferir_y_limpiar_nfs # Mueve a NFS
    limpiar_temporales     # Borra temporales

    echo "=== FIN PROCESO EXITOSO ==="
}

main 2>&1 | log

----/
# ==========================================
# CONFIGURACION DEL PROCESO CRYPT CBC TO PGP
# ==========================================

# --- Rutas Locales y Binarios ---
PGP_BIN="/opt/pgp/bin/pgp"
PATH_NFS_OUT="/nfshomedesa/usftp138/OUT/"

# --- Credenciales SFTP AS400 (Comunes) ---
SFTP_USER="usddsad"
SFTP_IP="10.10.10.10"
SFTP_KEY="/home/usddsad/.ssh/id_rsa"

# --- 1. Configuracion Archivo de PROPIEDADES (Llaves) ---
# Ruta y archivo remoto para obtener KEY e IV
REMOTE_DIR_PROPS="/Cifrado_OPENSSL/EPM/Project/properties"
REMOTE_FILE_PROPS="props.properties"

# --- 2. Configuracion Archivo de DATOS (Input Encriptado) ---
# Ruta remota donde esta el archivo .enc que vamos a procesar
REMOTE_DIR_INPUT="/home/usddsad/input_files/encrypted"
REMOTE_FILE_INPUT="LTAX1451.enc"

# --- Configuracion PGP (Salida) ---
PGP_RECIPIENT="seginfo@izipay.pe"
OUTPUT_FILENAME_PREFIX="LTAX1451"
OUTPUT_CONTROL_PREFIX="ECTRL10925"

# --- Nombres de archivos temporales (Interno) ---
# Nombres con los que se guardaran en la carpeta tmp local
TEMP_PROP_FILE="props.properties"
TEMP_DEC_FILE="LTAX1451.txt"

