#!/bin/bash
set -eou pipefail

# ==============================================================================
# SCRIPT: cryptCbcToPgp.sh
# DESCRIPCION: 1. Prepara entorno local (crea carpetas si no existen).
#              2. Descarga llaves y archivo encriptado del AS400.
#              3. Desencripta AES-CBC, encripta PGP y mueve a NFS.
# ==============================================================================

# 1. Obtener directorio local absoluto
DIR_LOCAL="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# 2. Cargar configuracion
CONFIG_FILE="${DIR_LOCAL}/config.ini"

if [ ! -f "$CONFIG_FILE" ]; then
    echo "Error: No se encuentra el archivo de configuracion $CONFIG_FILE"
    exit 1
fi

# shellcheck source=config.ini
source "$CONFIG_FILE"

# 3. Definicion de variables y rutas
DATE_YYMMDD=$(date +'%y%m%d')

# Rutas de trabajo internas (Estas se crearan automaticamente)
DIR_TMP="${DIR_LOCAL}/tmp"
DIR_OUT_LOCAL="${DIR_LOCAL}/OUT"

# Archivos
FILE_LOCAL_IFS="${DIR_TMP}/${TEMP_PROP_FILE}"
DEC_FILE="${DIR_TMP}/${TEMP_DEC_FILE}"
IN_ENC_FILE="${DIR_TMP}/${REMOTE_FILE_INPUT}"

# Nombres de Salida Finales
FINAL_PGP_NAME="${OUTPUT_FILENAME_PREFIX}${DATE_YYMMDD}.txt.pgp"
FINAL_CTL_NAME="${OUTPUT_CONTROL_PREFIX}${DATE_YYMMDD}.fin"

OUT_PGP_FILE="${DIR_OUT_LOCAL}/${FINAL_PGP_NAME}"
OUT_CONTROL_FILE="${DIR_OUT_LOCAL}/${FINAL_CTL_NAME}"

# ==============================================================================
# FUNCIONES
# ==============================================================================

log() {
    while IFS= read -r line; do
        echo "$(date +'%Y-%m-%d %H:%M:%S') - $line"
    done
}

preparar_entorno_local() {
    echo "--- PASO 0: Preparacion del entorno local ---"
    
    # Creamos directorios locales. 
    # mkdir -p crea la carpeta si no existe, y no da error si ya existe.
    if mkdir -p "$DIR_TMP" "$DIR_OUT_LOCAL"; then
        echo "Directorios locales verificados: $DIR_TMP y $DIR_OUT_LOCAL"
    else
        echo "Error: No se pudieron crear los directorios locales. Verifique permisos."
        return 1
    fi
}

check_remote_dir() {
    local dir_to_check="$1"
    echo "Verificando existencia de ruta remota: $dir_to_check ..."
    
    VERIF_REMOTE=$(sftp -i "$SFTP_KEY" -oBatchMode=yes -oStrictHostKeyChecking=no "${SFTP_USER}@${SFTP_IP}" 2>&1 <<EOF
cd $dir_to_check
exit
EOF
)
    if echo "$VERIF_REMOTE" | grep -Eqi "No such file|not found"; then
        echo "Error: El directorio remoto '$dir_to_check' no existe."
        return 1
    fi
    echo "Ruta remota verificada correctamente."
}

get_props_as400() {
    echo "--- PASO 1: Obtener Archivo de Propiedades (Llaves) ---"

    check_remote_dir "$REMOTE_DIR_PROPS"

    echo "Descargando propiedades..."
    if sftp -i "$SFTP_KEY" -oBatchMode=yes -oStrictHostKeyChecking=no "${SFTP_USER}@${SFTP_IP}" <<EOF >/dev/null 2>&1
lcd $DIR_TMP
cd $REMOTE_DIR_PROPS
get $REMOTE_FILE_PROPS
bye
EOF
    then
        echo "Archivo de propiedades descargado exitosamente."
    else
        echo "Error: Fallo la descarga de $REMOTE_FILE_PROPS"
        return 1
    fi
}

get_input_file_as400() {
    echo "--- PASO 2: Obtener Archivo Encriptado (Input) ---"
    
    check_remote_dir "$REMOTE_DIR_INPUT"

    echo "Descargando archivo de datos encriptado..."
    if sftp -i "$SFTP_KEY" -oBatchMode=yes -oStrictHostKeyChecking=no "${SFTP_USER}@${SFTP_IP}" <<EOF >/dev/null 2>&1
lcd $DIR_TMP
cd $REMOTE_DIR_INPUT
get $REMOTE_FILE_INPUT
bye
EOF
    then
        echo "Archivo de datos descargado exitosamente en TMP."
    else
        echo "Error: Fallo la descarga del archivo de datos $REMOTE_FILE_INPUT"
        return 1
    fi
}

obtener_key_iv() {
    echo "--- PASO 3: Extraccion de KEY e IV ---"

    if [ ! -f "$FILE_LOCAL_IFS" ]; then
        echo "Error: No existe el archivo de propiedades en TMP."
        return 1
    fi

    KEY_AES=$(sed -n '1p' "$FILE_LOCAL_IFS" | tr -d '\n\r ')
    IV_AES=$(sed -n '2p' "$FILE_LOCAL_IFS" | tr -d '\n\r ')

    if [ -z "$KEY_AES" ] || [ -z "$IV_AES" ]; then
        echo "Error: Datos de KEY o IV invalidos."
        return 1
    fi
    echo "Credenciales de cifrado obtenidas."
}

desencriptar_archivo() {
    echo "--- PASO 4: Desencriptado AES ---"

    if [ ! -f "$IN_ENC_FILE" ]; then
        echo "Error: No se encuentra el archivo encriptado descargado: $IN_ENC_FILE"
        return 1
    fi

    openssl enc -d -aes-256-cbc -K "$KEY_AES" -iv "$IV_AES" -in "$IN_ENC_FILE" -out "$DEC_FILE"

    if [ $? -eq 0 ]; then
        echo "Desencriptado exitoso. Generado: $DEC_FILE"
    else
        echo "Error: Fallo openssl."
        return 1
    fi
}

encriptar_archivo_pgp() {
    echo "--- PASO 5: Encriptado PGP ---"

    # Verificacion basica de existencia del binario PGP (ya que no lo podemos crear)
    if [ ! -x "$PGP_BIN" ]; then
        echo "Error: El ejecutable PGP no existe o no tiene permisos: $PGP_BIN"
        return 1
    fi

    "$PGP_BIN" --encrypt --recipient "$PGP_RECIPIENT" --input "$DEC_FILE" --output "$OUT_PGP_FILE" --always-trust

    if [ $? -eq 0 ]; then
        echo "Encriptado PGP exitoso."
    else
        echo "Error en PGP."
        return 1
    fi
}

genera_control() {
    echo "--- PASO 6: Generacion de Control ---"
    local count
    count=$(wc -l < "$DEC_FILE")
    count=$(echo "$count" | xargs)
    echo "Registros: $count" > "$OUT_CONTROL_FILE"
    echo "Control generado."
}

transferir_y_limpiar_nfs() {
    echo "--- PASO 7: Transferencia a NFS ---"

    # Verificamos carpeta NFS (No la podemos crear, debe existir)
    if [ ! -d "$PATH_NFS_OUT" ]; then
        echo "Error: Directorio NFS no accesible: $PATH_NFS_OUT"
        return 1
    fi

    echo "Limpiando NFS destino..."
    rm -f "${PATH_NFS_OUT:?}"/*

    echo "Copiando archivos..."
    cp "$OUT_PGP_FILE" "$PATH_NFS_OUT"
    cp "$OUT_CONTROL_FILE" "$PATH_NFS_OUT"

    if [ $? -eq 0 ]; then
        echo "Archivos copiados a NFS correctamente."
    else
        echo "Error al copiar a NFS."
        return 1
    fi
}

limpiar_temporales() {
    echo "Limpiando directorio TMP..."
    rm -rf "$DIR_TMP"
}

# ==============================================================================
# MAIN
# ==============================================================================

main() {
    echo "=== INICIO PROCESO EN $(hostname) ==="

    preparar_entorno_local # <--- AQUI SE CREAN TMP Y OUT SI NO EXISTEN
    
    get_props_as400
    get_input_file_as400
    obtener_key_iv
    desencriptar_archivo
    encriptar_archivo_pgp
    genera_control
    transferir_y_limpiar_nfs
    
    limpiar_temporales

    echo "=== FIN PROCESO EXITOSO ==="
}

main 2>&1 | log
