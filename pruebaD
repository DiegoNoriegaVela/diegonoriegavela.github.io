import java.io.*;
import java.nio.file.*;
import java.util.HashMap;
import java.util.Map;

public class IsoLogConverter {

    // Mapa est√°tico para conversi√≥n ultra r√°pida de Hex a Binario (4 bits)
    private static final Map<Character, String> HEX_A_BIN = new HashMap<>();
    static {
        HEX_A_BIN.put('0', "0000"); HEX_A_BIN.put('1', "0001");
        HEX_A_BIN.put('2', "0010"); HEX_A_BIN.put('3', "0011");
        HEX_A_BIN.put('4', "0100"); HEX_A_BIN.put('5', "0101");
        HEX_A_BIN.put('6', "0110"); HEX_A_BIN.put('7', "0111");
        HEX_A_BIN.put('8', "1000"); HEX_A_BIN.put('9', "1001");
        HEX_A_BIN.put('A', "1010"); HEX_A_BIN.put('B', "1011");
        HEX_A_BIN.put('C', "1100"); HEX_A_BIN.put('D', "1101");
        HEX_A_BIN.put('E', "1110"); HEX_A_BIN.put('F', "1111");
    }

    public static void main(String[] args) {
        String inputPath = null;

        // 1. Parsing de argumentos para aceptar "--input <ruta>"
        for (int i = 0; i < args.length; i++) {
            if ("--input".equals(args[i]) && i + 1 < args.length) {
                inputPath = args[i + 1];
            }
        }

        if (inputPath == null) {
            System.err.println("‚ùå Error: Debes especificar el archivo de entrada.");
            System.err.println("Uso: java IsoLogConverter --input \"/ruta/al/archivo/GCOFILE_DATI\"");
            return;
        }

        // Definir archivo de salida (agrega _BIN al nombre original)
        String outputPath = inputPath + "_BINARIO.txt";

        System.out.println("------------------------------------------------");
        System.out.println("üîÑ Iniciando conversi√≥n de ISO 8583 (Bitmap Hex -> Binario)...");
        System.out.println("üìÇ Entrada: " + inputPath);
        System.out.println("------------------------------------------------");

        try (BufferedReader br = new BufferedReader(new FileReader(inputPath));
             BufferedWriter bw = new BufferedWriter(new FileWriter(outputPath))) {

            String line;
            int lineNumber = 0;

            while ((line = br.readLine()) != null) {
                lineNumber++;
                line = line.trim();

                // Validaci√≥n b√°sica: La trama debe tener al menos 4 (MTI) + 32 (Bitmap) caracteres
                if (line.length() < 36) {
                    bw.write(line); // Escribimos la l√≠nea tal cual si no cumple el formato
                    bw.newLine();
                    continue;
                }

                try {
                    // --- L√ìGICA CORE ---
                    
                    // 1. MTI: Primeros 4 caracteres (0 a 4)
                    String mti = line.substring(0, 4);

                    // 2. Bitmap Hex: Siguientes 32 caracteres (4 a 36)
                    String bitmapHex = line.substring(4, 36);

                    // 3. Data Restante: Del caracter 36 al final
                    String restoTrama = line.substring(36);

                    // 4. Conversi√≥n del Bitmap
                    String bitmapBinario = convertirHexABinario(bitmapHex);

                    // 5. Reconstrucci√≥n y escritura
                    bw.write(mti + bitmapBinario + restoTrama);
                    bw.newLine();

                } catch (Exception e) {
                    System.err.println("‚ö†Ô∏è Error procesando l√≠nea " + lineNumber + ": " + e.getMessage());
                    bw.write(line); // Si falla, escribimos la original para no perder data
                    bw.newLine();
                }
            }

            System.out.println("‚úÖ ¬°Proceso completado!");
            System.out.println("üìÑ Archivo generado: " + outputPath);

        } catch (IOException e) {
            System.err.println("‚ùå Error de lectura/escritura: " + e.getMessage());
        }
    }

    /**
     * Convierte una cadena Hexadecimal de 32 caracteres a una cadena Binaria de 128 caracteres.
     * Mantiene los ceros a la izquierda.
     */
    private static String convertirHexABinario(String hex) {
        StringBuilder binario = new StringBuilder(128); // Capacidad exacta para evitar redimensionamiento
        
        for (char c : hex.toCharArray()) {
            // Convertimos a may√∫scula por seguridad y buscamos en el mapa
            String bits = HEX_A_BIN.get(Character.toUpperCase(c));
            if (bits != null) {
                binario.append(bits);
            } else {
                // Si encontramos un caracter no hex (basura), devolvemos "0000" o manejamos error
                binario.append("0000"); 
            }
        }
        return binario.toString();
    }
}
