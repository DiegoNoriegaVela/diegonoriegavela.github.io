import java.io.BufferedReader;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileReader;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

public class IsoBitmapHexToBinaryConverter {

    // Definimos las longitudes estándar según tu descripción
    private static final int MTI_LENGTH = 4;
    private static final int BITMAP_HEX_LENGTH = 32; // 32 chars hex = 128 bits = 16 bytes binarios
    private static final int TOTAL_PREFIX_LENGTH = MTI_LENGTH + BITMAP_HEX_LENGTH;

    public static void main(String[] args) {
        String inputFileBasePath = null;
        String outputFileBasePath = null;

        // 1. Procesamiento de parámetros de línea de comandos
        for (int i = 0; i < args.length; i++) {
            if ("--input".equals(args[i]) && i + 1 < args.length) {
                inputFileBasePath = args[i + 1];
                i++;
            } else if ("--output".equals(args[i]) && i + 1 < args.length) {
                outputFileBasePath = args[i + 1];
                i++;
            }
        }

        // Validación de parámetros
        if (inputFileBasePath == null || outputFileBasePath == null) {
            System.err.println("Error: Faltan parámetros.");
            System.err.println("Uso: java IsoBitmapHexToBinaryConverter --input <ruta_archivo_origen> --output <ruta_archivo_destino>");
            System.exit(1);
        }

        File inputFile = new File(inputFileBasePath);
        File outputFile = new File(outputFileBasePath);

        if (!inputFile.exists() || !inputFile.isFile()) {
            System.err.println("Error: El archivo de entrada no existe o no es válido: " + inputFileBasePath);
            System.exit(1);
        }

        System.out.println("Iniciando procesamiento...");
        System.out.println("Entrada (Hex Bitmap): " + inputFile.getAbsolutePath());
        System.out.println("Salida (Bin Bitmap): " + outputFile.getAbsolutePath());

        // 2. Proceso de lectura y conversión
        // Usamos BufferedReader para leer el origen como texto (línea por línea)
        // Usamos BufferedOutputStream para escribir el destino porque contendrá datos binarios mixtos
        try (BufferedReader reader = new BufferedReader(new FileReader(inputFile, StandardCharsets.US_ASCII));
             BufferedOutputStream writer = new BufferedOutputStream(new FileOutputStream(outputFile))) {

            String line;
            int lineNumber = 0;
            int processedCount = 0;

            // Leemos el archivo línea por línea
            while ((line = reader.readLine()) != null) {
                lineNumber++;

                // Validación básica: la línea debe tener al menos la longitud del MTI + Bitmap Hex
                if (line.length() < TOTAL_PREFIX_LENGTH) {
                    System.err.println("Advertencia: Línea " + lineNumber + " omitida por ser demasiado corta: " + line);
                    continue;
                }

                try {
                    // A. Extraer el MTI (primeros 4 caracteres) - NO SE TOCA
                    String mtiStr = line.substring(0, MTI_LENGTH);

                    // B. Extraer el Bitmap en Hexadecimal (siguientes 32 caracteres) - ESTO SE CONVERTIRÁ
                    String hexBitmapStr = line.substring(MTI_LENGTH, TOTAL_PREFIX_LENGTH);

                    // C. Extraer el resto de la trama (desde el carácter 36 en adelante) - NO SE TOCA
                    String restOfDataStr = line.substring(TOTAL_PREFIX_LENGTH);

                    // --- FASE DE CONVERSIÓN ---
                    // Convertir la cadena hexadecimal de 32 chars a un array de 16 bytes binarios
                    byte[] binaryBitmap = hexStringToByteArray(hexBitmapStr);

                    // --- FASE DE ESCRITURA ---
                    // Escribimos los bytes en el orden correcto al archivo de salida

                    // 1. Escribir MTI como bytes ASCII
                    writer.write(mtiStr.getBytes(StandardCharsets.US_ASCII));

                    // 2. Escribir el Bitmap convertido como bytes BINARIOS puros
                    writer.write(binaryBitmap);

                    // 3. Escribir el resto de los datos como bytes ASCII
                    writer.write(restOfDataStr.getBytes(StandardCharsets.US_ASCII));

                    // 4. Añadir salto de línea (importante si el archivo original tenía múltiples líneas)
                    // Usamos un salto de línea estándar ASCII
                    writer.write('\n');

                    processedCount++;

                } catch (IllegalArgumentException e) {
                    System.err.println("Error en línea " + lineNumber + ": El bitmap no es una cadena hexadecimal válida (" + line.substring(MTI_LENGTH, TOTAL_PREFIX_LENGTH) + "). Línea omitida.");
                } catch (StringIndexOutOfBoundsException e) {
                     System.err.println("Error de índice en línea " + lineNumber + ". Línea omitida.");
                }
            }

            // Asegurar que todos los datos se escriban en el disco
            writer.flush();
            System.out.println("Procesamiento finalizado. Se convirtieron " + processedCount + " registros exitosamente.");

        } catch (IOException e) {
            System.err.println("Error crítico de Entrada/Salida:");
            e.printStackTrace();
        }
    }

    /**
     * Método auxiliar crítico.
     * Convierte una cadena hexadecimal (ej: "F010") en su representación de bytes binarios.
     * Se asume fielmente que la entrada es una cadena hex válida de longitud par.
     * @param s La cadena hexadecimal (debe ser de 32 caracteres para este caso de uso).
     * @return El array de bytes resultante (será de 16 bytes).
     */
    private static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        if (len % 2 != 0) {
             throw new IllegalArgumentException("La cadena hexadecimal debe tener una longitud par");
        }
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            // Toma dos caracteres hex, los convierte a dígitos numéricos y los combina en un byte
            int digit1 = Character.digit(s.charAt(i), 16);
            int digit2 = Character.digit(s.charAt(i + 1), 16);

            if (digit1 == -1 || digit2 == -1) {
                 throw new IllegalArgumentException("Carácter no hexadecimal encontrado en el bitmap");
            }

            data[i / 2] = (byte) ((digit1 << 4) + digit2);
        }
        return data;
    }
}

