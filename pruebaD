// Método de ENCRIPTACIÓN modificado
// Ahora recibe el parámetro charsetName (ej. "UTF-8", "ISO-8859-1", "Windows-1252")
public static void encryptContentFile(String iPath, String oPath, String key, String charsetName) throws EncryptionException {
    try {
        // 1. Obtenemos el objeto Charset a partir del nombre recibido
        Charset charset = Charset.forName(charsetName);

        // 2. Usamos ese charset para LEER el archivo de entrada
        String fileContent = Files.readString(Paths.get(iPath), charset);

        AESGCMCipher aesgcmCipher = new AESGCMCipher();
        // Ciframos el contenido (esto sigue siendo igual)
        String encryptedContent = aesgcmCipher.encrypt(fileContent, key);

        // 3. IMPORTANTE: Usamos el MISMO charset para ESCRIBIR el archivo de salida.
        // Si lo leíste en ANSI, es buena práctica escribirlo igual para mantener consistencia,
        // aunque podrías forzar UTF-8 aquí si quisieras estandarizar la salida.
        // He simplificado las opciones de escritura a las estándar de Java NIO.
        Files.writeString(Paths.get(oPath), encryptedContent, charset, 
                          StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);

        System.out.println("Cifrado exitoso: " + iPath + " -> " + oPath);

    } catch (IOException e) {
        throw new EncryptionException("Error de E/S al leer/escribir el archivo: " + iPath + ". Verifica permisos o rutas.", e);
    } catch (Exception e) {
        // Capturamos Exception general para atrapar errores de cifrado Y errores si el nombre del charset es inválido.
        throw new EncryptionException("Error durante el proceso (posible charset inválido o error de cifrado): " + iPath + ". Charset usado: " + charsetName, e);
    }
}


// Método de DESENCRIPTACIÓN modificado
public static void decryptContentFile(String iPath, String oPath, String key, String charsetName) throws EncryptionException {
    try {
        // 1. Obtenemos el Charset
        Charset charset = Charset.forName(charsetName);

        // 2. Leemos el archivo cifrado usando ese charset
        String fileContent = Files.readString(Paths.get(iPath), charset);

        AESGCMCipher aesgcmCipher = new AESGCMCipher();
        // Desciframos
        String decryptedContent = aesgcmCipher.decrypt(fileContent, key);

        // 3. Escribimos el resultado usando el mismo charset para recuperar los caracteres originales (ñ, $, etc.)
        Files.writeString(Paths.get(oPath), decryptedContent, charset, 
                          StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
                          
        System.out.println("Descifrado exitoso: " + iPath + " -> " + oPath);

    } catch (IOException e) {
         throw new EncryptionException("Error de E/S al leer/escribir el archivo: " + iPath, e);
    } catch (Exception e) {
        // Capturamos Exception general por si el nombre del charset es malo o falla el descifrado.
        throw new EncryptionException("Error al descifrar o charset inválido: " + iPath + ". Verifica que la llave y el charset (" + charsetName + ") sean correctos.", e);
    }
}
