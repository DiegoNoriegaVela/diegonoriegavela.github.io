#!/bin/bash
set -eou pipefail

# ==============================================================================
# SCRIPT: cryptCbcToPgp.sh
# DESCRIPCION: Descarga llaves, desencripta AES-CBC, encripta PGP y mueve a NFS.
# ==============================================================================

# 1. Obtener directorio local absoluto donde reside el script (PWD dinamico)
DIR_LOCAL="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# 2. Cargar archivo de configuracion
CONFIG_FILE="${DIR_LOCAL}/config.ini"

if [ ! -f "$CONFIG_FILE" ]; then
    echo "Error: No se encuentra el archivo de configuracion $CONFIG_FILE"
    exit 1
fi

source "$CONFIG_FILE"

# 3. Definicion de variables derivadas y fecha
# Formato AAMMDD (Ej: 251126)
DATE_YYMMDD=$(date +'%y%m%d')

# Rutas de trabajo
DIR_OUT_LOCAL="${DIR_LOCAL}/OUT"

# Archivos
FILE_LOCAL_IFS="${DIR_LOCAL}/${TEMP_PROP_FILE}"
DEC_FILE="${DIR_LOCAL}/${TEMP_DEC_FILE}"
IN_ENC_FILE="${DIR_LOCAL}/${INPUT_ENC_FILE}"

# Nombres de Salida Finales
FINAL_PGP_NAME="${OUTPUT_FILENAME_PREFIX}${DATE_YYMMDD}.txt.pgp"
FINAL_CTL_NAME="${OUTPUT_CONTROL_PREFIX}${DATE_YYMMDD}.fin"

OUT_PGP_FILE="${DIR_OUT_LOCAL}/${FINAL_PGP_NAME}"
OUT_CONTROL_FILE="${DIR_OUT_LOCAL}/${FINAL_CTL_NAME}"

# Variables globales para KEY e IV
KEY_AES=""
IV_AES=""

# Crear directorios necesarios si no existen
mkdir -p "$DIR_OUT_LOCAL"

# ==============================================================================
# FUNCIONES
# ==============================================================================

verificar_sftp() {
    echo "Inicio verificacion conexion SFTP con ${SFTP_IP}..."

    # Probar conexion SFTP
    sftp -i "$SFTP_KEY" -oBatchMode=yes -oConnectTimeout=5 -oStrictHostKeyChecking=no "${SFTP_USER}@${SFTP_IP}" <<EOF
exit
EOF

    if [ $? -ne 0 ]; then
        echo "Error: No se pudo establecer conexion SFTP con ${SFTP_IP}"
        return 1
    fi

    # Verificar si la ruta remota existe
    echo "Se verifica ruta remota..."
    VERIF_REMOTE=$(sftp -i "$SFTP_KEY" "${SFTP_USER}@${SFTP_IP}" 2>&1 <<EOF
cd $REMOTE_DIR_AS400
exit
EOF
)
    
    if echo "$VERIF_REMOTE" | grep -Eqi "No such file|failed"; then
        echo "Error: El directorio remoto $REMOTE_DIR_AS400 no existe en el servidor SFTP ${SFTP_IP}"
        return 1
    fi
    
    echo "Conexion y ruta remota verificadas correctamente."
}

get_as400() {
    echo "Inicio SFTP GET desde ${SFTP_IP}..."

    # Ejecutar transferencia SFTP
    sftp -i "$SFTP_KEY" -oBatchMode=yes -oConnectTimeout=10 -oStrictHostKeyChecking=no "${SFTP_USER}@${SFTP_IP}" <<EOF
lcd $DIR_LOCAL
cd $REMOTE_DIR_AS400
get $REMOTE_FILE_AS400
bye
EOF
    
    if [ $? -ne 0 ]; then
        echo "Error: Fallo la transferencia SFTP desde $SFTP_IP"
        return 1
    fi

    echo "Descarga SFTP exitosa en: $DIR_LOCAL"
}

obtener_key_iv() {
    echo "Inicio obtencion de KEY e IV desde propiedades..."
    
    if [ ! -f "$FILE_LOCAL_IFS" ]; then
        echo "Error: No existe el archivo de propiedades $FILE_LOCAL_IFS"
        return 1
    fi

    # Extrae linea 1 (Key) y linea 2 (IV) limpiando saltos de linea y retornos
    KEY_AES=$(sed -n '1p' "$FILE_LOCAL_IFS" | tr -d '\n\r ')
    IV_AES=$(sed -n '2p' "$FILE_LOCAL_IFS" | tr -d '\n\r ')

    # Validacion simple de que no esten vacios
    if [ -z "$KEY_AES" ] || [ -z "$IV_AES" ]; then
        echo "Error: La KEY o el IV estan vacios."
        return 1
    fi

    echo "KEY e IV obtenidos correctamente."
}

desencriptar_archivo() {
    echo "Inicio desencriptado CBC AES..."
    
    if [ ! -f "$IN_ENC_FILE" ]; then
        echo "Error: No existe el archivo encriptado entrada: $IN_ENC_FILE"
        return 1
    fi

    # Se usa -K mayuscula para llave hexadecimal
    openssl enc -d -aes-256-cbc -K "$KEY_AES" -iv "$IV_AES" -in "$IN_ENC_FILE" -out "$DEC_FILE"
    
    if [ $? -eq 0 ]; then
        echo "Fin de desencriptado. Archivo generado: $DEC_FILE"
    else
        echo "Error: Fallo el comando openssl."
        return 1
    fi
}

encriptar_archivo_pgp() {
    echo "Inicio encriptado PGP..."
    
    # Se usa --always-trust para evitar fallos si la llave no esta firmada localmente
    "$PGP_BIN" --encrypt --recipient "$PGP_RECIPIENT" --input "$DEC_FILE" --output "$OUT_PGP_FILE" --always-trust
    
    if [ $? -eq 0 ]; then
        echo "Fin de encriptado PGP. Archivo: $OUT_PGP_FILE"
    else
        echo "Error: Fallo encriptacion PGP."
        return 1
    fi
}

genera_control() {
    echo "Generando archivo de control..."
    # Cuenta lineas del archivo desencriptado
    local count
    count=$(wc -l < "$DEC_FILE")
    # Limpia espacios en blanco del wc
    count=$(echo "$count" | xargs)
    
    echo "Registros: $count" > "$OUT_CONTROL_FILE"
    echo "Archivo de control generado: $OUT_CONTROL_FILE"
}

transferir_y_limpiar_nfs() {
    echo "Iniciando transferencia a NFS: $PATH_NFS_OUT"

    # Verificar que el directorio NFS existe y es escribible
    if [ ! -d "$PATH_NFS_OUT" ]; then
        echo "Error: El directorio NFS $PATH_NFS_OUT no existe o no es accesible."
        return 1
    fi

    # 1. Limpiar directorio NFS destino
    echo "Limpiando directorio destino NFS..."
    # Usamos precaucion: solo borrar archivos dentro del path especifico
    # rm -f "${PATH_NFS_OUT:?}/"* <-- La sintaxis :? evita borrar si la variable esta vacia
    rm -f "${PATH_NFS_OUT}"/*
    
    # 2. Copiar archivos nuevos
    echo "Copiando archivos a NFS..."
    cp "$OUT_PGP_FILE" "$PATH_NFS_OUT"
    cp "$OUT_CONTROL_FILE" "$PATH_NFS_OUT"

    if [ $? -eq 0 ]; then
        echo "Transferencia a NFS completada exitosamente."
    else
        echo "Error al copiar archivos al NFS."
        return 1
    fi
}

limpiar_temporales() {
    echo "Eliminando archivos temporales..."
    rm -f "$FILE_LOCAL_IFS" "$DEC_FILE"
}

# ==============================================================================
# MAIN
# ==============================================================================

main() {
    echo "=== INICIO DE RUTINA SERVIDOR $(hostname) ==="
    
    # Ejecucion paso a paso
    verificar_sftp
    get_as400
    obtener_key_iv
    desencriptar_archivo
    encriptar_archivo_pgp
    genera_control
    
    # Paso especial NFS
    transferir_y_limpiar_nfs

    # Limpieza final
    limpiar_temporales

    echo "=== FIN DE RUTINA EXITOSO ==="
}

# Ejecutar Main y redirigir errores a la salida estandar
main 2>&1

