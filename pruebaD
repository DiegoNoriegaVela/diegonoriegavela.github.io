import java.io.BufferedReader;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream; 
import java.io.FileOutputStream;
import java.io.InputStreamReader; 
import java.io.IOException;

public class IsoBitmapHexToBinaryConverter {

    private static final int MTI_LENGTH = 4;
    private static final int BITMAP_HEX_LENGTH = 32; 
    private static final int TOTAL_PREFIX_LENGTH = MTI_LENGTH + BITMAP_HEX_LENGTH;

    public static void main(String[] args) {
        String inputFileBasePath = null;
        String outputFileBasePath = null;

        // Procesamiento de argumentos
        for (int i = 0; i < args.length; i++) {
            if ("--input".equals(args[i]) && i + 1 < args.length) {
                inputFileBasePath = args[i + 1];
                i++;
            } else if ("--output".equals(args[i]) && i + 1 < args.length) {
                outputFileBasePath = args[i + 1];
                i++;
            }
        }

        // Validaciones básicas
        if (inputFileBasePath == null || outputFileBasePath == null) {
            System.err.println("Error: Faltan parametros obligatorios.");
            System.err.println("Uso: java IsoBitmapHexToBinaryConverter --input <ruta_origen> --output <ruta_destino>");
            System.exit(1);
        }

        File inputFile = new File(inputFileBasePath);
        File outputFile = new File(outputFileBasePath);

        if (!inputFile.exists() || !inputFile.isFile()) {
            System.err.println("Error: El archivo de entrada no existe: " + inputFileBasePath);
            System.exit(1);
        }

        System.out.println("Iniciando procesamiento (Compatible AS/400)...");
        System.out.println("Entrada: " + inputFile.getAbsolutePath());
        System.out.println("Salida:  " + outputFile.getAbsolutePath());

        BufferedReader reader = null;
        BufferedOutputStream writer = null;

        try {
            // 1. Lectura: Usamos InputStreamReader con "US-ASCII" para asegurar que 
            // leemos la entrada hexadecimal correctamente en cualquier entorno (incluido EBCDIC).
            reader = new BufferedReader(new InputStreamReader(new FileInputStream(inputFile), "US-ASCII"));
            
            // 2. Escritura: Usamos BufferedOutputStream estándar.
            // En tu entorno AS/400, esto parece generar el formato visual "Ø" que necesitas.
            writer = new BufferedOutputStream(new FileOutputStream(outputFile));

            String line;
            int lineNumber = 0;
            int processedCount = 0;

            while ((line = reader.readLine()) != null) {
                lineNumber++;

                // Ignorar líneas vacías o incompletas
                if (line.length() < TOTAL_PREFIX_LENGTH) {
                    continue;
                }

                try {
                    // Separar las partes
                    String mtiStr = line.substring(0, MTI_LENGTH);
                    String hexBitmapStr = line.substring(MTI_LENGTH, TOTAL_PREFIX_LENGTH);
                    String restOfDataStr = line.substring(TOTAL_PREFIX_LENGTH);

                    // Convertir el bitmap hex a bytes
                    byte[] binaryBitmap = hexStringToByteArray(hexBitmapStr);

                    // --- ESCRITURA ---
                    // Escribimos las partes. Al usar getBytes("US-ASCII") para el texto
                    // y escribir el bitmap binario directamente, dejamos que el entorno
                    // maneje la representación final.

                    // 1. Escribir MTI (como ASCII)
                    writer.write(mtiStr.getBytes("US-ASCII"));

                    // 2. Escribir Bitmap BINARIO
                    writer.write(binaryBitmap);

                    // 3. Escribir el resto de los datos (como ASCII)
                    writer.write(restOfDataStr.getBytes("US-ASCII"));
                    
                    // 4. Escribir salto de línea estándar
                    writer.write('\n');

                    processedCount++;

                } catch (IllegalArgumentException e) {
                    System.err.println("Error en línea " + lineNumber + ": Bitmap hexadecimal inválido. Se omite el registro.");
                } catch (Exception e) {
                     System.err.println("Error inesperado procesando línea " + lineNumber + ": " + e.getMessage());
                }
            }
            
            // Asegurar que todos los datos queden guardados en disco
            writer.flush();
            System.out.println("Procesamiento completado. Se generaron " + processedCount + " registros.");

        } catch (IOException e) {
            System.err.println("Error crítico de Entrada/Salida: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // Cierre seguro de recursos para versiones antiguas de Java
            try {
                if (reader != null) reader.close();
                if (writer != null) writer.close();
            } catch (IOException ex) {
                // Ignorar errores al cerrar
            }
        }
    }

    /**
     * Convierte una cadena hexadecimal de 32 caracteres en un array de 16 bytes.
     */
    private static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        // Validación estricta para bitmap ISO8583 primario (32 chars hex)
        if (len != BITMAP_HEX_LENGTH) {
             throw new IllegalArgumentException("La longitud del bitmap hex debe ser exactamente 32 caracteres");
        }
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            int digit1 = Character.digit(s.charAt(i), 16);
            int digit2 = Character.digit(s.charAt(i + 1), 16);
            if (digit1 == -1 || digit2 == -1) {
                 throw new IllegalArgumentException("Carácter no hexadecimal encontrado en el bitmap");
            }
            // Combina dos dígitos hex en un byte
            data[i / 2] = (byte) ((digit1 << 4) + digit2);
        }
        return data;
    }
}
