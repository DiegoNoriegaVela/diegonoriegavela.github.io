#!/bin/bash
set -eou pipefail

# ==============================================================================
# SCRIPT: cryptCbcToPgp.sh
# DESCRIPCION: Descarga llaves, desencripta AES-CBC, encripta PGP y mueve a NFS.
# ==============================================================================

# 1. Obtener directorio local absoluto donde reside el script (PWD dinámico)
DIR_LOCAL="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# 2. Cargar archivo de configuración
CONFIG_FILE="${DIR_LOCAL}/config.ini"

if [ ! -f "$CONFIG_FILE" ]; then
    echo "Error: No se encuentra el archivo de configuración $CONFIG_FILE"
    exit 1
fi

source "$CONFIG_FILE"

# 3. Definicion de variables derivadas y fecha
# Formato AAMMDD (Ej: 251126)
DATE_YYMMDD=$(date +'%y%m%d')
TIMESTAMP=$(date +'%Y-%m-%d %H:%M:%S')

# Rutas de trabajo
DIR_TMP="${DIR_LOCAL}/tmp"
DIR_LOGS="${DIR_LOCAL}/logs"
DIR_OUT_LOCAL="${DIR_LOCAL}/OUT"

# Archivos
LOG_FILE="${DIR_LOGS}/proceso_${DATE_YYMMDD}.log"
FILE_LOCAL_IFS="${DIR_TMP}/${TEMP_PROP_FILE}"
DEC_FILE="${DIR_TMP}/${TEMP_DEC_FILE}"
IN_ENC_FILE="${DIR_LOCAL}/${INPUT_ENC_FILE}"

# Nombres de Salida Finales
FINAL_PGP_NAME="${OUTPUT_FILENAME_PREFIX}${DATE_YYMMDD}.txt.pgp"
FINAL_CTL_NAME="${OUTPUT_CONTROL_PREFIX}${DATE_YYMMDD}.fin"

OUT_PGP_FILE="${DIR_OUT_LOCAL}/${FINAL_PGP_NAME}"
OUT_CONTROL_FILE="${DIR_OUT_LOCAL}/${FINAL_CTL_NAME}"

# Crear directorios necesarios si no existen
mkdir -p "$DIR_TMP" "$DIR_LOGS" "$DIR_OUT_LOCAL"

# ==============================================================================
# FUNCIONES
# ==============================================================================

log() {
    # Función para loguear con timestamp, lee del stdin
    while IFS= read -r line; do
        echo "$(date +'%Y-%m-%d %H:%M:%S') - $line"
        echo "$(date +'%Y-%m-%d %H:%M:%S') - $line" >> "$LOG_FILE"
    done
}

get_as400() {
    echo "Inicio SFTP GET desde ${SFTP_IP}..."

    # Verificar conectividad básica (opcional, pero recomendado)
    # echo "Probando conexión..."

    # Ejecutar SFTP
    # Usamos StrictHostKeyChecking=no para evitar prompts interactivos si cambia la fingerprint
    if sftp -i "$SFTP_KEY" -oBatchMode=yes -oConnectTimeout=10 -oStrictHostKeyChecking=no "${SFTP_USER}@${SFTP_IP}" <<EOF
lcd $DIR_TMP
cd $REMOTE_DIR_AS400
get $REMOTE_FILE_AS400
bye
EOF
    then
        echo "Descarga SFTP exitosa en: $DIR_TMP"
    else
        echo "Error: Fallo la transferencia SFTP desde $SFTP_IP"
        return 1
    fi
}

obtener_key_iv() {
    echo "Inicio obtención de KEY e IV desde propiedades..."
    
    if [ ! -f "$FILE_LOCAL_IFS" ]; then
        echo "Error: No existe el archivo de propiedades $FILE_LOCAL_IFS"
        return 1
    fi

    # Extrae linea 1 (Key) y linea 2 (IV) limpiando saltos de linea y retornos
    KEY_AES=$(sed -n '1p' "$FILE_LOCAL_IFS" | tr -d '\n\r ')
    IV_AES=$(sed -n '2p' "$FILE_LOCAL_IFS" | tr -d '\n\r ')

    # Validación simple de que no estén vacíos
    if [ -z "$KEY_AES" ] || [ -z "$IV_AES" ]; then
        echo "Error: La KEY o el IV están vacíos."
        return 1
    fi

    echo "KEY e IV obtenidos correctamente." # Por seguridad no los imprimimos en el log
}

desencriptar_archivo() {
    echo "Inicio desencriptado CBC AES..."
    
    if [ ! -f "$IN_ENC_FILE" ]; then
        echo "Error: No existe el archivo encriptado entrada: $IN_ENC_FILE"
        return 1
    fi

    openssl enc -d -aes-256-cbc -K "$KEY_AES" -iv "$IV_AES" -in "$IN_ENC_FILE" -out "$DEC_FILE"
    
    if [ $? -eq 0 ]; then
        echo "Fin de desencriptado. Archivo generado: $DEC_FILE"
    else
        echo "Error: Falló el comando openssl."
        return 1
    fi
}

encriptar_archivo_pgp() {
    echo "Inicio encriptado PGP..."
    
    # Se usa --always-trust para evitar fallos si la llave no está firmada localmente
    "$PGP_BIN" --encrypt --recipient "$PGP_RECIPIENT" --input "$DEC_FILE" --output "$OUT_PGP_FILE" --always-trust
    
    if [ $? -eq 0 ]; then
        echo "Fin de encriptado PGP. Archivo: $OUT_PGP_FILE"
    else
        echo "Error: Falló encriptación PGP."
        return 1
    fi
}

genera_control() {
    echo "Generando archivo de control..."
    # Cuenta lineas del archivo desencriptado
    local count
    count=$(wc -l < "$DEC_FILE")
    # Limpia espacios en blanco del wc
    count=$(echo "$count" | xargs)
    
    echo "Registros: $count" > "$OUT_CONTROL_FILE"
    echo "Archivo de control generado: $OUT_CONTROL_FILE"
}

transferir_y_limpiar_nfs() {
    echo "Iniciando transferencia a NFS: $PATH_NFS_OUT"

    # Verificar que el directorio NFS existe y es escribible
    if [ ! -d "$PATH_NFS_OUT" ]; then
        echo "Error: El directorio NFS $PATH_NFS_OUT no existe o no es accesible."
        return 1
    fi

    # 1. Limpiar directorio NFS destino
    echo "Limpiando directorio destino NFS..."
    # Usamos precaución: solo borrar archivos dentro del path especifico
    # rm -f "${PATH_NFS_OUT:?}/"* <-- La sintaxis :? evita borrar si la variable está vacía (seguridad)
    rm -f "${PATH_NFS_OUT}"/*
    
    # 2. Copiar archivos nuevos
    echo "Copiando archivos a NFS..."
    cp "$OUT_PGP_FILE" "$PATH_NFS_OUT"
    cp "$OUT_CONTROL_FILE" "$PATH_NFS_OUT"

    if [ $? -eq 0 ]; then
        echo "Transferencia a NFS completada exitosamente."
    else
        echo "Error al copiar archivos al NFS."
        return 1
    fi
}

limpiar_temporales() {
    echo "Eliminando directorio temporal: $DIR_TMP"
    rm -rf "$DIR_TMP"
}

# ==============================================================================
# MAIN
# ==============================================================================

main() {
    echo "=== INICIO DE RUTINA SERVIDOR $(hostname) ==="
    
    # Ejecucion paso a paso
    get_as400
    obtener_key_iv
    desencriptar_archivo
    encriptar_archivo_pgp
    genera_control
    
    # Paso especial NFS
    transferir_y_limpiar_nfs

    # Limpieza final
    limpiar_temporales

    echo "=== FIN DE RUTINA EXITOSO ==="
}

# Ejecutar Main y redirigir todo (stdout y stderr) a la función log
# El "2>&1" redirige errores a la salida estándar para que el pipe los capture
main 2>&1 | log

-----

# ==========================================
# CONFIGURACION DEL PROCESO CRYPT CBC TO PGP
# ==========================================

# --- Rutas Locales y Binarios ---
PGP_BIN="/opt/pgp/bin/pgp"
# La ruta base se calcula automaticamente en el script,
# pero aqui definimos las subcarpetas relativas o rutas absolutas extras.
PATH_NFS_OUT="/nfshomedesa/usftp138/OUT/"

# --- Configuración SFTP AS400 ---
SFTP_USER="usddsad"
SFTP_IP="10.10.10.10" 
SFTP_KEY="/home/usddsad/.ssh/id_rsa"
# Ruta remota donde buscar el archivo de propiedades/llaves
REMOTE_DIR_AS400="/Cifrado_OPENSSL/EPM/Project/properties"
REMOTE_FILE_AS400="props.properties"

# --- Archivo a Desencriptar (Entrada) ---
# Nombre del archivo encriptado local (o ruta relativa)
INPUT_ENC_FILE="IN/LTAX1451.enc"

# --- Configuración PGP (Salida) ---
PGP_RECIPIENT="seginfo@izipay.pe"
# Prefijo para el archivo de salida (Ej: LTAX1451 + FECHA)
OUTPUT_FILENAME_PREFIX="LTAX1451"
OUTPUT_CONTROL_PREFIX="ECTRL10925"

# --- Nombres de archivos temporales (Interno) ---
TEMP_PROP_FILE="props.properties"
TEMP_DEC_FILE="LTAX1451.txt"
